[{"content":"编译环境  操作系统： macOS Big Sur 11.4 20F71 x86_64 CPU架构： x86 BootStrap: zulu17.28.13-ca-jdk17.0.0-macosx_x64  编译版本： https://github.com/openjdk/jdk\n下载jdk源码 git clone https://git.openjdk.java.net/jdk/\n根据发布版本记录切换到 jdk17-ga版本\ngit checkout jdk-17-ga 运行配置 构建之前彻底清空上一次编译结果\nmake dist-clean 配置 BootStrap JDK。编译jdk17需要jdk17，下载已经编译好的jdk作为BootStrap JDK 同一个终端下配置JAVA_HOME\nexport JAVA_HOME=${jdk17 home} 最后执行bash configure， 处理WARN等日志\n成功结果\nConfiguration summary: * Name: macosx-x86_64-server-release * Debug level: release * HS debug level: product * JVM variants: server * JVM features: server: 'cds compiler1 compiler2 dtrace epsilongc g1gc jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc' * OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64 * Version string: 17-internal+0-adhoc.linran.jdk (17-internal) Tools summary: * Boot JDK: openjdk version \u0026quot;17\u0026quot; 2021-09-14 LTS OpenJDK Runtime Environment Zulu17.28+13-CA (build 17+35-LTS) OpenJDK 64-Bit Server VM Zulu17.28+13-CA (build 17+35-LTS, mixed mode, sharing) (at /Users/linran/dev/java-jdk/zulu17.28.13-ca-jdk17.0.0-macosx_x64) * Toolchain: clang (clang/LLVM from Xcode 13.0) * C Compiler: Version 13.0.0 (at /usr/bin/clang) * C++ Compiler: Version 13.0.0 (at /usr/bin/clang++) Build performance summary: * Cores to use: 8 * Memory limit: 32768 MB 编译 执行make images，编译整个jdk镜像 完成编译结果\nCreating jdk image Creating CDS archive for jdk image Creating CDS-NOCOOPS archive for jdk image Stopping sjavac server Finished building target 'images' in configuration 'macosx-x86_64-server-release' 验证结果 ./build/*/images/jdk/bin/java -version 运行基础测试  make run-test-tier1 REF  https://github.com/openjdk/jdk/blob/master/doc/building.md https://segmentfault.com/a/1190000023251649  ","permalink":"https://razielez.github.io/posts/jdk%E7%BC%96%E8%AF%91%E8%AE%B0%E5%BD%95/","summary":"编译环境  操作系统： macOS Big Sur 11.4 20F71 x86_64 CPU架构： x86 BootStrap: zulu17.28.13-ca-jdk17.0.0-macosx_x64  编译版本： https://github.com/openjdk/jdk\n下载jdk源码 git clone https://git.openjdk.java.net/jdk/\n根据发布版本记录切换到 jdk17-ga版本\ngit checkout jdk-17-ga 运行配置 构建之前彻底清空上一次编译结果\nmake dist-clean 配置 BootStrap JDK。编译jdk17需要jdk17，下载已经编译好的jdk作为BootStrap JDK 同一个终端下配置JAVA_HOME\nexport JAVA_HOME=${jdk17 home} 最后执行bash configure， 处理WARN等日志\n成功结果\nConfiguration summary: * Name: macosx-x86_64-server-release * Debug level: release * HS debug level: product * JVM variants: server * JVM features: server: 'cds compiler1 compiler2 dtrace epsilongc g1gc jfr jni-check jvmci jvmti management nmt parallelgc serialgc services shenandoahgc vm-structs zgc' * OpenJDK target: OS: macosx, CPU architecture: x86, address length: 64 * Version string: 17-internal+0-adhoc.","title":"Jdk编译记录"},{"content":"博客的重新整理 之前用过wp、hexo体验都不是非常完美，记得毕业的时候还经常用hexo记录一些日常，使用mac后就没在重新搭建环境荒废掉了，也慢慢切向notion，现在主要还是喜欢用命令行直接写一些东西，打开一个笔记本软件也挺麻烦的，notion看起来也不是很有必要性，想一想还是需要记录一些日常开发和生活遇到的一些问题和想法，由此这便是这个博客重新整理的一些初衷。\n剩下的还有一些旧的数据的迁移和废弃\n 废弃掉一些旧的数据 同步新的数据 数据同步最佳实践 坚持下来\u0026hellip;  ","permalink":"https://razielez.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86/","summary":"博客的重新整理 之前用过wp、hexo体验都不是非常完美，记得毕业的时候还经常用hexo记录一些日常，使用mac后就没在重新搭建环境荒废掉了，也慢慢切向notion，现在主要还是喜欢用命令行直接写一些东西，打开一个笔记本软件也挺麻烦的，notion看起来也不是很有必要性，想一想还是需要记录一些日常开发和生活遇到的一些问题和想法，由此这便是这个博客重新整理的一些初衷。\n剩下的还有一些旧的数据的迁移和废弃\n 废弃掉一些旧的数据 同步新的数据 数据同步最佳实践 坚持下来\u0026hellip;  ","title":"博客的重新整理"},{"content":"This is a blog of a Java developer.\nConnect Me  Email: linran@live.com  ","permalink":"https://razielez.github.io/about/","summary":"about","title":"About"},{"content":"工具  jps jstat -gcutil 9448 1000 jconsole.exe  IDEA调优后的参数 -server -Xms3g -Xmx3g -XX:NewRatio=5 -Xss16m -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:ConcGCThreads=4 -XX:ReservedCodeCacheSize=512m -XX:+TieredCompilation -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow 相关参数介绍 # custom IntelliJ IDEA VM options ##################JVM模式############################ # IDEA的JVM以Server模式启动（新生代默认使用ParNew） -server ##################内存分配############################ # 堆初始值占用3G，意味着IDEA启动即分配3G内存 -Xms3g # 堆最大值占用3G -Xmx3g # 强制JVM在启动时申请到足够的堆内存（否则IDEA启动时堆初始大小不足3g） -XX:+AlwaysPreTouch # 年轻代与老年代比例为1:3（默认值是1:4），降低年轻代的回收频率 -XX:NewRatio=3 # 栈帧大小为16m -Xss16m ##################老年代回收器############################ # 使用CMS老年代回收器 -XX:+UseConcMarkSweepGC # CMS的重新标记步骤：多线程一起执行 -XX:+CMSParallelRemarkEnabled # CMS的并发标记步骤：启用4个线程并发标记（理论上越多越好，前提是CPU核心足够多） -XX:ConcGCThreads=4 ##################JIT编译器############################ # 代码缓存，用于存放Just In Time编译后的本地代码，如果塞满，JVM将只解释执行，不再编译native代码。 -XX:ReservedCodeCacheSize=512m # 分层编译，JIT编译优化越来越好，IDEA运行时间越久越快 -XX:+TieredCompilation # 节省64位指针占用的空间，代价是JVM额外开销 -XX:+UseCompressedOops # 增大软引用在JVM中的存活时长（堆空闲空间越大越久） -XX:SoftRefLRUPolicyMSPerMB=50 -Dsun.io.useCanonCaches=false -Djava.net.preferIPv4Stack=true -Djsse.enableSNIExtension=false ","permalink":"https://razielez.github.io/posts/%E4%B8%80%E6%AC%A1%E5%AF%B9idea%E7%9A%84%E8%B0%83%E4%BC%98/","summary":"工具  jps jstat -gcutil 9448 1000 jconsole.exe  IDEA调优后的参数 -server -Xms3g -Xmx3g -XX:NewRatio=5 -Xss16m -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:ConcGCThreads=4 -XX:ReservedCodeCacheSize=512m -XX:+TieredCompilation -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow 相关参数介绍 # custom IntelliJ IDEA VM options ##################JVM模式############################ # IDEA的JVM以Server模式启动（新生代默认使用ParNew） -server ##################内存分配############################ # 堆初始值占用3G，意味着IDEA启动即分配3G内存 -Xms3g # 堆最大值占用3G -Xmx3g # 强制JVM在启动时申请到足够的堆内存（否则IDEA启动时堆初始大小不足3g） -XX:+AlwaysPreTouch # 年轻代与老年代比例为1:3（默认值是1:4），降低年轻代的回收频率 -XX:NewRatio=3 # 栈帧大小为16m -Xss16m ##################老年代回收器############################ # 使用CMS老年代回收器 -XX:+UseConcMarkSweepGC # CMS的重新标记步骤：多线程一起执行 -XX:+CMSParallelRemarkEnabled # CMS的并发标记步骤：启用4个线程并发标记（理论上越多越好，前提是CPU核心足够多） -XX:ConcGCThreads=4 ##################JIT编译器############################ # 代码缓存，用于存放Just In Time编译后的本地代码，如果塞满，JVM将只解释执行，不再编译native代码。 -XX:ReservedCodeCacheSize=512m # 分层编译，JIT编译优化越来越好，IDEA运行时间越久越快 -XX:+TieredCompilation # 节省64位指针占用的空间，代价是JVM额外开销 -XX:+UseCompressedOops # 增大软引用在JVM中的存活时长（堆空闲空间越大越久） -XX:SoftRefLRUPolicyMSPerMB=50 -Dsun.","title":"对IDEA调优"},{"content":" 闲着没事情做几道SQL题。 Orcal SQL: 在线SQL测试\nMySQL指定进入某个端口命令\nmysql -uroot -p -P 3307 问题描述 1.学生表 Student(SID,Sname,Sage,Ssex) \u0026ndash;SID 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别. 2.课程表 Course(CID,Cname,TID) \u0026ndash;CID \u0026ndash;课程编号,Cname 课程名称,TID 教师编号. 3.教师表 Teacher(TID,Tname) \u0026ndash;TID 教师编号,Tname 教师姓名. 4.成绩表 SC(SID,CID,score) \u0026ndash;SID 学生编号,CID 课程编号,score 分数. 建表语句:\ncreate table Student(SID varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10)); insert into Student values(\u0026#39;01\u0026#39; , \u0026#39;赵雷\u0026#39; , \u0026#39;1990-01-01\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;02\u0026#39; , \u0026#39;钱电\u0026#39; , \u0026#39;1990-12-21\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;03\u0026#39; , \u0026#39;孙风\u0026#39; , \u0026#39;1990-05-20\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;04\u0026#39; , \u0026#39;李云\u0026#39; , \u0026#39;1990-08-06\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;05\u0026#39; , \u0026#39;周梅\u0026#39; , \u0026#39;1991-12-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;06\u0026#39; , \u0026#39;吴兰\u0026#39; , \u0026#39;1992-03-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;07\u0026#39; , \u0026#39;郑竹\u0026#39; , \u0026#39;1989-07-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;08\u0026#39; , \u0026#39;王菊\u0026#39; , \u0026#39;1990-01-20\u0026#39; , \u0026#39;女\u0026#39;); create table Course(CID varchar(10),Cname nvarchar(10),TID varchar(10)); insert into Course values(\u0026#39;01\u0026#39; , \u0026#39;语文\u0026#39; , \u0026#39;02\u0026#39;); insert into Course values(\u0026#39;02\u0026#39; , \u0026#39;数学\u0026#39; , \u0026#39;01\u0026#39;); insert into Course values(\u0026#39;03\u0026#39; , \u0026#39;英语\u0026#39; , \u0026#39;03\u0026#39;); create table Teacher(TID varchar(10),Tname nvarchar(10)); insert into Teacher values(\u0026#39;01\u0026#39; , \u0026#39;张三\u0026#39;); insert into Teacher values(\u0026#39;02\u0026#39; , \u0026#39;李四\u0026#39;); insert into Teacher values(\u0026#39;03\u0026#39; , \u0026#39;王五\u0026#39;); create table SC(SID varchar(10),CID varchar(10),score decimal(18,1)); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;02\u0026#39; , 90); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;03\u0026#39; , 99); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;01\u0026#39; , 70); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;02\u0026#39; , 60); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;02\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;01\u0026#39; , 50); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;02\u0026#39; , 30); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;03\u0026#39; , 20); insert into SC values(\u0026#39;05\u0026#39; , \u0026#39;01\u0026#39; , 76); insert into SC values(\u0026#39;05\u0026#39; , \u0026#39;02\u0026#39; , 87); insert into SC values(\u0026#39;06\u0026#39; , \u0026#39;01\u0026#39; , 31); insert into SC values(\u0026#39;06\u0026#39; , \u0026#39;03\u0026#39; , 34); insert into SC values(\u0026#39;07\u0026#39; , \u0026#39;02\u0026#39; , 89); insert into SC values(\u0026#39;07\u0026#39; , \u0026#39;03\u0026#39; , 98); 题目  查询\u0026quot;01\u0026quot;课程比\u0026quot;02\u0026quot;课程成绩高的学生的信息及课程分数   查询同时存在\u0026quot;01\u0026quot;课程和\u0026quot;02\u0026quot;课程的情况 结果:  +------+-------+---------------------+------+------------+------------+ | SID | Sname | Sage | Ssex | 01课程分数 | 02课程分数 | +------+-------+---------------------+------+------------+------------+ | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | 70.0 | 60.0 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | 50.0 | 30.0 | +------+-------+---------------------+------+------------+------------+ 2 rows in set (0.00 sec) select a.* , b.score 01课程分数, c.score 02课程分数 from Student a, SC b, SC c where a.SID=b.SID and a.SID=c.SID and b.CID=\u0026#34;01\u0026#34; and c.CID=\u0026#34;02\u0026#34; and b.score\u0026gt;c.score;  查询同时存在\u0026quot;01\u0026quot;课程和\u0026quot;02\u0026quot;课程的情况和存在\u0026quot;01\u0026quot;课程但可能不存在\u0026quot;02\u0026quot;课程的情况(不存在时显示为null)(以下存在相同内容时不再解释). 结果:  +------+-------+---------------------+------+------------+------------+ | SID | Sname | Sage | Ssex | 01课程分数 | 02课程分数 | +------+-------+---------------------+------+------------+------------+ | 01 | 赵雷 | 1990-01-01 00:00:00 | 男 | 80.0 | 90.0 | | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | 70.0 | 60.0 | | 03 | 孙风 | 1990-05-20 00:00:00 | 男 | 80.0 | 80.0 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | 50.0 | 30.0 | | 05 | 周梅 | 1991-12-01 00:00:00 | 女 | 76.0 | 87.0 | | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | 31.0 | NULL | +------+-------+---------------------+------+------------+------------+ 6 rows in set (0.00 sec) select a.*,b.score 01课程分数,c.score 02课程分数 from Student a left join SC b on b.SID=a.SID and b.CID=\u0026#39;01\u0026#39; left join SC c on c.SID=a.SID and c.CID=\u0026#39;02\u0026#39; where b.score\u0026gt;isnull(c.score); 查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩. CAST()函数:CAST('12.5' AS decimal(9,2)) 如果通过CAST()函数将这个值转换为decimal表示精度与小数位数分别为9与2. 结果:  +------+-------+-----------+ | SID | Sname | avg_socre | +------+-------+-----------+ | 01 | 赵雷 | 89.67 | | 02 | 钱电 | 70.00 | | 03 | 孙风 | 80.00 | | 05 | 周梅 | 81.50 | | 07 | 郑竹 | 93.50 | +------+-------+-----------+ 5 rows in set (0.00 sec) select a.SID,a.Sname,cast(avg(b.score) as decimal(10,2))avg_socre from Student a, SC b where a.SID=b.SID group by a.SID,a.Sname having cast(avg(b.score) as decimal(10,2))\u0026gt;=60 order by a.SID; 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩.   查询所有有成绩的SQL. 结果:  +------+-------+----------+--------+ | SID | Sname | 选课总数 | 总成绩 | +------+-------+----------+--------+ | 01 | 赵雷 | 3 | 269.0 | | 02 | 钱电 | 3 | 210.0 | | 03 | 孙风 | 3 | 240.0 | | 04 | 李云 | 3 | 100.0 | | 05 | 周梅 | 2 | 163.0 | | 06 | 吴兰 | 2 | 65.0 | | 07 | 郑竹 | 2 | 187.0 | +------+-------+----------+--------+ 7 rows in set (0.00 sec) select a.SID,a.Sname,count(b.CID) 选课总数,sum(b.score) 总成绩 from Student a, SC b where a.SID=b.SID group by a.SID, a.Sname order by a.SID  查询所有(包括有成绩和无成绩)的SQL. 结果:  +------+-------+--------------+------------+ | SID | Sname | count(b.CID) | sum(score) | +------+-------+--------------+------------+ | 01 | 赵雷 | 3 | 269.0 | | 02 | 钱电 | 3 | 210.0 | | 03 | 孙风 | 3 | 240.0 | | 04 | 李云 | 3 | 100.0 | | 05 | 周梅 | 2 | 163.0 | | 06 | 吴兰 | 2 | 65.0 | | 07 | 郑竹 | 2 | 187.0 | | 08 | 王菊 | 0 | NULL | +------+-------+--------------+------------+ 8 rows in set (0.00 sec) select a.SID,a.Sname,count(b.CID),sum(score) from Student a left join SC b on a.SID=b.SID group by a.SID, a.Sname order by a.SID; 查询\u0026quot;李\u0026quot;姓老师的数量. 结果:  +----------+ | 教师数量 | +----------+ | 1 | +----------+ 1 row in set (0.00 sec) -- 1 select count(Tname)教师数量 from Teacher where Tname like \u0026#39;李%\u0026#39;; -- 2 select count(Tname)教师数量 from Teacher where left(Tname, 1)=\u0026#39;李\u0026#39;; 查询学过\u0026quot;张三\u0026quot;老师授课的同学的信息. 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 01 | 赵雷 | 1990-01-01 00:00:00 | 男 | | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | | 03 | 孙风 | 1990-05-20 00:00:00 | 男 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | | 05 | 周梅 | 1991-12-01 00:00:00 | 女 | | 07 | 郑竹 | 1989-07-01 00:00:00 | 女 | +------+-------+---------------------+------+ 6 rows in set (0.00 sec) select Student.* from Student,SC,Course,Teacher where Student.SID=SC.SID and SC.CID=Course.CID and Course.TID=Teacher.TID and Teacher.Tname=\u0026#34;张三\u0026#34; order by Student.SID; 查询没学过\u0026quot;张三\u0026quot;老师授课的同学的信息 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | | 08 | 王菊 | 1990-01-20 00:00:00 | 女 | +------+-------+---------------------+------+ 2 rows in set (0.00 sec) select s.* from Student s where SID not in ( select SC.SID from SC,Course,Teacher where SC.CID=Course.CID and Course.TID=Teacher.TID and Teacher.Tname=\u0026#34;张三\u0026#34; ) order by s.SID; 查询学过编号为\u0026quot;01\u0026quot;并且也学过编号为\u0026quot;02\u0026quot;的课程的同学的信息. 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 01 | 赵雷 | 1990-01-01 00:00:00 | 男 | | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | | 03 | 孙风 | 1990-05-20 00:00:00 | 男 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | | 05 | 周梅 | 1991-12-01 00:00:00 | 女 | +------+-------+---------------------+------+ 5 rows in set (0.00 sec) -- 1 select Student.* from Student,SC where Student.SID=SC.SID and SC.CID=\u0026#39;01\u0026#39; and exists ( select * from SC sc_2 where sc_2.CID=\u0026#39;02\u0026#39; and sc_2.SID=SC.SID ) order by Student.SID; -- 2 select s.* from Student s where s.SID in ( select SID from ( select SID from SC where SC.CID=\u0026#39;01\u0026#39; union all select SID from SC where SC.CID=\u0026#39;02\u0026#39; ) t group by SID having count(1) = 2 ) order by s.SID; 查询没有学全所有课程的同学的信息. 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 05 | 周梅 | 1991-12-01 00:00:00 | 女 | | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | | 07 | 郑竹 | 1989-07-01 00:00:00 | 女 | +------+-------+---------------------+------+ 3 rows in set (0.01 sec) -- 1 select Student.* from Student,SC where Student.SID=SC.SID group by Student.SID,Student.Sname,Student.Sage,Student.Ssex having count(CID) \u0026lt; (select count(CID) from Course); -- 2 select Student.* from Student left join SC on Student.SID=SC.SID group by Student.SID,Student.Sname,Student.Sage,Student.Ssex having count(CID)\u0026lt;(select count(CID) from Course); select * from Student left join SC on Student.SID=SC.SID left join Course on SC.CID=Course.CID order by Student.SID; 查询至少有一门课与学号为\u0026quot;01\u0026quot;的同学所学相同的同学的信息. 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | | 03 | 孙风 | 1990-05-20 00:00:00 | 男 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | | 05 | 周梅 | 1991-12-01 00:00:00 | 女 | | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | | 07 | 郑竹 | 1989-07-01 00:00:00 | 女 | +------+-------+---------------------+------+ 6 rows in set (0.00 sec) select distinct Student.* from Student, SC where Student.SID=SC.SID and SC.CID in ( select CID from SC where SC.SID=\u0026#39;01\u0026#39; ) and Student.SID!=\u0026#39;01\u0026#39;; 查询没学过\u0026quot;张三\u0026quot;老师讲授的任一门课程的学生姓名. 结果:  +------+-------+ | SID | Sname | +------+-------+ | 06 | 吴兰 | | 08 | 王菊 | +------+-------+ 2 rows in set (0.00 sec) select Student.SID,Student.Sname from Student where Student.SID not in ( select distinct SC.SID from SC,Course,Teacher where SC.CID=Course.CID and Course.TID=Teacher.TID and Teacher.Tname=\u0026#34;张三\u0026#34; ) order by Student.SID; 查询和\u0026quot;01\u0026quot;号的同学学习的课程完全相同的其他同学的信息. 结果:  +------+-------+---------------------+------+ | SID | Sname | Sage | Ssex | +------+-------+---------------------+------+ | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | | 03 | 孙风 | 1990-05-20 00:00:00 | 男 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | +------+-------+---------------------+------+ 3 rows in set (0.00 sec) -- 这个只是按数量算... select Student.* from Student where SID in ( select distinct SC.SID from SC where SID!=\u0026#39;01\u0026#39; and SC.CID in ( select distinct CID from SC where SID=\u0026#39;01\u0026#39; ) group by SC.SID having count(1)=(select count(1) from SC where SID=\u0026#39;01\u0026#39;) ); 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩. 结果:  +------+-------+-----------+ | SID | Sname | avg_score | +------+-------+-----------+ | 04 | 李云 | 33.33 | | 06 | 吴兰 | 32.50 | +------+-------+-----------+ 2 rows in set (0.00 sec) -- group by(分组)having(条件) 用法. -- select Ssex from Student group by Ssex having Ssex!=\u0026#39;男\u0026#39;; select SID from SC where score \u0026lt; 60 group by SID having count(1) \u0026gt;= 2 select Student.SID, Student.Sname, cast(avg(score) as decimal(10, 2)) avg_score from Student, SC where Student.SID=SC.SID and Student.SID in ( select SID from SC where score\u0026lt;60 group by SID having count(1)\u0026gt;=2 ) group by Student.SID,Student.Sname; 检索\u0026quot;01\u0026quot;课程分数小于60，按分数降序排列的学生信息. 结果:  +------+-------+---------------------+------+-------+------+ | SID | Sname | Sage | Ssex | score | CID | +------+-------+---------------------+------+-------+------+ | 04 | 李云 | 1990-08-06 00:00:00 | 男 | 50.0 | 01 | | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | 34.0 | 03 | | 06 | 吴兰 | 1992-03-01 00:00:00 | 女 | 31.0 | 01 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | 30.0 | 02 | | 04 | 李云 | 1990-08-06 00:00:00 | 男 | 20.0 | 03 | +------+-------+---------------------+------+-------+------+ 5 rows in set (0.00 sec) select distinct Student.*,SC.score,Course.CID from Student,SC,Course where Student.SID=SC.SID and SC.CID=Course.CID and Student.SID in ( select SID from SC,Course where SC.CID=Course.CID and SC.score\u0026lt;60 and Course.CID=\u0026#39;01\u0026#39; ) order by SC.score desc; 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩. 结果:  +------+------+------+------+------+--------+ | 学号 | 姓名 | 语文 | 数学 | 英语 | 平均分 | +------+------+------+------+------+--------+ | 07 | 郑竹 | NULL | 89.0 | 98.0 | 93.50 | | 01 | 赵雷 | 80.0 | 90.0 | 99.0 | 89.67 | | 05 | 周梅 | 76.0 | 87.0 | NULL | 81.50 | | 03 | 孙风 | 80.0 | 80.0 | 80.0 | 80.00 | | 02 | 钱电 | 70.0 | 60.0 | 80.0 | 70.00 | | 04 | 李云 | 50.0 | 30.0 | 20.0 | 33.33 | | 06 | 吴兰 | 31.0 | NULL | 34.0 | 32.50 | | 08 | 王菊 | NULL | NULL | NULL | NULL | +------+------+------+------+------+--------+ 8 rows in set (0.00 sec) -- 列转行 select a.SID 学号,a.Sname 姓名, max(case c.Cname when \u0026#39;语文\u0026#39; then b.score else null end) 语文, max(case c.Cname when \u0026#39;数学\u0026#39; then b.score else null end) 数学, max(case c.Cname when \u0026#39;英语\u0026#39; then b.score else null end) 英语, cast(avg(b.score) as decimal(18, 2)) 平均分 from student a left join SC b on a.SID=b.SID left join Course c on b.CID=c.CID group by a.SID, a.Sname order by 平均分 desc; 查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 \u0026ndash;及格为\u0026gt;=60，中等为：70-80，优良为：80-90，优秀为：\u0026gt;=90. 结果:  +----------+----------+--------+--------+--------+--------+--------+--------+--------+ | 课程编号 | 课程名称 | 最高分 | 最低分 | 平均分 | 及格率 | 中等率 | 优良率 | 优秀率 | +----------+----------+--------+--------+--------+--------+--------+--------+--------+ | 01 | 语文 | 80.0 | 31.0 | 64.50 | 66.67 | 33.33 | 33.33 | 0.00 | | 02 | 数学 | 90.0 | 30.0 | 72.67 | 83.33 | 0.00 | 50.00 | 16.67 | | 03 | 英语 | 99.0 | 20.0 | 68.50 | 66.67 | 0.00 | 33.33 | 33.33 | +----------+----------+--------+--------+--------+--------+--------+--------+--------+ 3 rows in set (0.07 sec) -- 1 select m.CID 课程编号,m.Cname 课程名称,max(n.score) 最高分,min(n.score) 最低分, cast(avg(n.score) as decimal(18,2)) 平均分, cast((select count(1) from sc where CID=m.CID and score\u0026gt;=60)*100.0/(select count(1) from sc where CID=m.CID) as decimal(18, 2)) 及格率, cast((select count(1) from sc where CID = m.CID and score \u0026gt;= 70 and score \u0026lt; 80 )*100.0 / (select count(1) from sc where CID = m.CID) as decimal(18,2)) 中等率 , cast((select count(1) from sc where CID = m.CID and score \u0026gt;= 80 and score \u0026lt; 90 )*100.0 / (select count(1) from sc where CID = m.CID) as decimal(18,2)) 优良率 , cast((select count(1) from sc where CID = m.CID and score \u0026gt;= 90)*100.0 / (select count(1) from sc where CID = m.CID) as decimal(18,2)) 优秀率 from course m,sc n where m.CID=n.CID group by m.CID,m.Cname order by m.CID; -- 2 select m.CID 课程编号 , m.Cname 课程名称 , (select max(score) from SC where CID = m.CID) 最高分 , (select min(score) from SC where CID = m.CID) 最低分 , (select cast(avg(score) as decimal(18,2)) from SC where CID = m.CID) 平均分 , cast((select count(1) from SC where CID = m.CID and score \u0026gt;= 60)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 及格率, cast((select count(1) from SC where CID = m.CID and score \u0026gt;= 70 and score \u0026lt; 80 )*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 中等率 , cast((select count(1) from SC where CID = m.CID and score \u0026gt;= 80 and score \u0026lt; 90 )*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优良率 , cast((select count(1) from SC where CID = m.CID and score \u0026gt;= 90)*100.0 / (select count(1) from SC where CID = m.CID) as decimal(18,2)) 优秀率 from Course m order by m.CID;  我实在是太难了\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip; 16. 按各科成绩进行排序，并显示排名.\n Score重复时保留名次空缺. 结果:  --- emmm  Score重复时合并名次(DENSE_RANK完成). 结果:  查询学生的总成绩并进行排名.   查询学生的总成绩. 结果:   查询学生的总成绩并进行排名，sql 2000用子查询完成，分总分重复时保留名次空缺和不保留名次空缺两种。 结果:   查询学生的总成绩并进行排名，sql 2005用rank,DENSE_RANK完成，分总分重复时保留名次空缺和不保留名次空缺两种。 结果:  未完待续~\n","permalink":"https://razielez.github.io/posts/%E5%87%A0%E9%81%93sql%E7%BB%83%E4%B9%A0%E9%A2%98/","summary":"闲着没事情做几道SQL题。 Orcal SQL: 在线SQL测试\nMySQL指定进入某个端口命令\nmysql -uroot -p -P 3307 问题描述 1.学生表 Student(SID,Sname,Sage,Ssex) \u0026ndash;SID 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别. 2.课程表 Course(CID,Cname,TID) \u0026ndash;CID \u0026ndash;课程编号,Cname 课程名称,TID 教师编号. 3.教师表 Teacher(TID,Tname) \u0026ndash;TID 教师编号,Tname 教师姓名. 4.成绩表 SC(SID,CID,score) \u0026ndash;SID 学生编号,CID 课程编号,score 分数. 建表语句:\ncreate table Student(SID varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10)); insert into Student values(\u0026#39;01\u0026#39; , \u0026#39;赵雷\u0026#39; , \u0026#39;1990-01-01\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;02\u0026#39; , \u0026#39;钱电\u0026#39; , \u0026#39;1990-12-21\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;03\u0026#39; , \u0026#39;孙风\u0026#39; , \u0026#39;1990-05-20\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;04\u0026#39; , \u0026#39;李云\u0026#39; , \u0026#39;1990-08-06\u0026#39; , \u0026#39;男\u0026#39;); insert into Student values(\u0026#39;05\u0026#39; , \u0026#39;周梅\u0026#39; , \u0026#39;1991-12-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;06\u0026#39; , \u0026#39;吴兰\u0026#39; , \u0026#39;1992-03-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;07\u0026#39; , \u0026#39;郑竹\u0026#39; , \u0026#39;1989-07-01\u0026#39; , \u0026#39;女\u0026#39;); insert into Student values(\u0026#39;08\u0026#39; , \u0026#39;王菊\u0026#39; , \u0026#39;1990-01-20\u0026#39; , \u0026#39;女\u0026#39;); create table Course(CID varchar(10),Cname nvarchar(10),TID varchar(10)); insert into Course values(\u0026#39;01\u0026#39; , \u0026#39;语文\u0026#39; , \u0026#39;02\u0026#39;); insert into Course values(\u0026#39;02\u0026#39; , \u0026#39;数学\u0026#39; , \u0026#39;01\u0026#39;); insert into Course values(\u0026#39;03\u0026#39; , \u0026#39;英语\u0026#39; , \u0026#39;03\u0026#39;); create table Teacher(TID varchar(10),Tname nvarchar(10)); insert into Teacher values(\u0026#39;01\u0026#39; , \u0026#39;张三\u0026#39;); insert into Teacher values(\u0026#39;02\u0026#39; , \u0026#39;李四\u0026#39;); insert into Teacher values(\u0026#39;03\u0026#39; , \u0026#39;王五\u0026#39;); create table SC(SID varchar(10),CID varchar(10),score decimal(18,1)); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;02\u0026#39; , 90); insert into SC values(\u0026#39;01\u0026#39; , \u0026#39;03\u0026#39; , 99); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;01\u0026#39; , 70); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;02\u0026#39; , 60); insert into SC values(\u0026#39;02\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;01\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;02\u0026#39; , 80); insert into SC values(\u0026#39;03\u0026#39; , \u0026#39;03\u0026#39; , 80); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;01\u0026#39; , 50); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;02\u0026#39; , 30); insert into SC values(\u0026#39;04\u0026#39; , \u0026#39;03\u0026#39; , 20); insert into SC values(\u0026#39;05\u0026#39; , \u0026#39;01\u0026#39; , 76); insert into SC values(\u0026#39;05\u0026#39; , \u0026#39;02\u0026#39; , 87); insert into SC values(\u0026#39;06\u0026#39; , \u0026#39;01\u0026#39; , 31); insert into SC values(\u0026#39;06\u0026#39; , \u0026#39;03\u0026#39; , 34); insert into SC values(\u0026#39;07\u0026#39; , \u0026#39;02\u0026#39; , 89); insert into SC values(\u0026#39;07\u0026#39; , \u0026#39;03\u0026#39; , 98); 题目  查询\u0026quot;01\u0026quot;课程比\u0026quot;02\u0026quot;课程成绩高的学生的信息及课程分数   查询同时存在\u0026quot;01\u0026quot;课程和\u0026quot;02\u0026quot;课程的情况 结果:  +------+-------+---------------------+------+------------+------------+ | SID | Sname | Sage | Ssex | 01课程分数 | 02课程分数 | +------+-------+---------------------+------+------------+------------+ | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | 70.","title":"SQL练习题"},{"content":" 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\nJava线程中我们构造两个相互等待对方释放资源的线程就构成了死锁。\n代码：\npublic class DeadLockSimulation { private static String A = \u0026#34;a\u0026#34;; private static String B = \u0026#34;b\u0026#34;; public static void main(String[] args) { new DeadLockSimulation().deadLock(); } private void deadLock() { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (A) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (B) { System.out.println(\u0026#34;t1\u0026#34;); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (B) { synchronized (A) { System.out.println(\u0026#34;t2\u0026#34;); } } } }); t1.start(); t2.start(); } } 运行上边的代码产生死锁。JDK自带的工具有jconsole、jvisualvm、jstack等。\njvisualvm 运行jvisualvm如下：\n发现提示检测到死锁。\njstack 查看进程号：\njps // 查看Java任务进程号 2784 Jps 8672 Main 18068 Launcher 12520 KotlinCompileDaemon 16776 DeadLockSimulation 9576 16668 RemoteMavenServer 运行jstack。\njstack [进程号] // 查看当前进程堆栈 Found one Java-level deadlock: ============================= \u0026#34;Thread-0\u0026#34;: waiting to lock monitor 0x0000012f11b53e80 (object 0x0000000741d763e8, a java.lang.String), which is held by \u0026#34;Thread-1\u0026#34; \u0026#34;Thread-1\u0026#34;: waiting to lock monitor 0x0000012f11b51e80 (object 0x0000000741d76400, a java.lang.String), which is held by \u0026#34;Thread-0\u0026#34; Java stack information for the threads listed above: =================================================== \u0026#34;Thread-0\u0026#34;: at com.lin.juc.mydesign.DeadLockSimulation$1.run(DeadLockSimulation.java:28) - waiting to lock \u0026lt;0x0000000741d763e8\u0026gt; (a java.lang.String) - locked \u0026lt;0x0000000741d76400\u0026gt; (a java.lang.String) at java.lang.Thread.run(java.base@11.0.1/Thread.java:834) \u0026#34;Thread-1\u0026#34;: at com.lin.juc.mydesign.DeadLockSimulation$2.run(DeadLockSimulation.java:39) - waiting to lock \u0026lt;0x0000000741d76400\u0026gt; (a java.lang.String) - locked \u0026lt;0x0000000741d763e8\u0026gt; (a java.lang.String) at java.lang.Thread.run(java.base@11.0.1/Thread.java:834) Found 1 deadlock. MXBean MXBean是JDK自带的用于扫描程序是否存在死锁包， 但是扫描的过程中存在性能损耗。\n代码：\npublic class ScanDeadLock { public void scanDeadLock() { ThreadMXBean mxBean = ManagementFactory.getThreadMXBean(); Runnable runnable = () -\u0026gt; { long[] ids = mxBean.findDeadlockedThreads(); System.out.println(\u0026#34;扫描死锁...\u0026#34;); if (ids != null) { ThreadInfo[] threadInfos = mxBean.getThreadInfo(ids); for (ThreadInfo info : threadInfos) { System.out.println(\u0026#34;info = \u0026#34; + info); } } }; ExecutorService executorService = Executors.newScheduledThreadPool(4); executorService.execute(runnable); } } 死锁预防  避免一个线程同时获取多个锁。 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。 尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。  ","permalink":"https://razielez.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81/","summary":"死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。\nJava线程中我们构造两个相互等待对方释放资源的线程就构成了死锁。\n代码：\npublic class DeadLockSimulation { private static String A = \u0026#34;a\u0026#34;; private static String B = \u0026#34;b\u0026#34;; public static void main(String[] args) { new DeadLockSimulation().deadLock(); } private void deadLock() { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (A) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (B) { System.out.println(\u0026#34;t1\u0026#34;); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (B) { synchronized (A) { System.","title":"Java线程检测死锁"},{"content":" Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。\nJava 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。\n有以下常规实现方法：\n一、数据抽象成一个类，对数据操作的方法封装在类里\npublic class MyData1 { private int j = 0; public static void main(String[] args) { MyData1 data = new MyData1(); AddRunnable addRunnable = new AddRunnable(data); DecRunnable decRunnable = new DecRunnable(data); new Thread(addRunnable).start(); new Thread(decRunnable).start(); } public synchronized void add() { j++; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public synchronized void dec() { j--; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public int getData() { return j; } } class AddRunnable implements Runnable { MyData1 data1 = new MyData1(); public AddRunnable(MyData1 data1) { this.data1 = data1; } @Override public void run() { data1.add(); } } class DecRunnable implements Runnable { MyData1 data1 = new MyData1(); public DecRunnable(MyData1 data1) { this.data1 = data1; } @Override public void run() { data1.dec(); } } 二、Runnable对象作为一个类的内部类，共享数据作为这个类的内部变量，每个线程对类的操作封装在外部类中，从而实现各个数据之间的互斥和同步，内部类的各个Runnable对象都可以调用外部方法\npublic class MyData2 { private int j = 0; public synchronized void add() { j++; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public synchronized void dec() { j--; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public int getData() { return j; } } class TestThread { public static void main(String[] args) { final MyData2 data = new MyData2(); for (int i = 0; i \u0026lt; 2; i++) { new Thread(new Runnable() { @Override public void run() { data.add(); } }).start(); new Thread(new Runnable() { @Override public void run() { data.dec(); } }).start(); } } } ","permalink":"https://razielez.github.io/posts/java%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/","summary":"Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。\nJava 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。\n有以下常规实现方法：\n一、数据抽象成一个类，对数据操作的方法封装在类里\npublic class MyData1 { private int j = 0; public static void main(String[] args) { MyData1 data = new MyData1(); AddRunnable addRunnable = new AddRunnable(data); DecRunnable decRunnable = new DecRunnable(data); new Thread(addRunnable).start(); new Thread(decRunnable).start(); } public synchronized void add() { j++; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public synchronized void dec() { j--; System.out.println(\u0026#34;线程：\u0026#34; + Thread.currentThread().getName() + \u0026#34; j为：\u0026#34; + j); } public int getData() { return j; } } class AddRunnable implements Runnable { MyData1 data1 = new MyData1(); public AddRunnable(MyData1 data1) { this.","title":"Java两个线程之间共享数据"},{"content":" Java基础 面向对象六原则一法则 单一职责原则（Single-Resposibility Principle） 一个类只做它该做的事情。（单一职责原则想表达的就是\u0026quot;高内聚\u0026quot;，写代码最终极的原则只有六个字\u0026quot;高内聚、低耦合\u0026quot;，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）。\n开放封闭原则（Open-Closed principle） 软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：1. 抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；2. 封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性）\nLiskov替换原则（Liskov-Substituion Principle） 里氏替换原则，任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）\n依赖倒置原则（Dependecy-Inversion Principle） 面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）\n接口隔离原则（Interface-Segregation Principle） 接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、 分离的手段主要有以下两种：1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。\n合成聚合复用原则 优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）\n迪米特法则 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。\nJava如何实现的平台无关  Java语言规范  通过规定Java语言中基本数据类型的取值范围和行为   Class文件  所有Java文件要编译成统一的Class文件   Java虚拟机  通过Java虚拟机将Class文件转成对应平台的二进制文件等    JVM支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）\n值传递、引用传递 Java中只有值传递\npublic class Main { public static void main(String[] args) { int a = 10; Integer b = 20; int[] arr = {1, 2}; swap(a, b); System.out.println(String.format(\u0026#34;a:%d b:%d\u0026#34;, a, b)); swap(arr); System.out.println(Arrays.toString(arr)); } // 对于对象而言传递的是对象引用的地址作为值  static void swap(int a, Integer b) { int t = a; a = b; b = t; } static void swap(int[] arr) { arr[0] = 996; } } /** OutPut: a:10 b:20 [996, 2] **/  值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。 引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。  成员变量和方法作用域    作用域 当前类 同package 子孙类 不同package     public √ √ √ √   protected √ √ √ ×   fridendly(默认) √ √ × ×   private √ × × ×    例子：protected在其子类中可以访问，无论是子类内部还是子类的实例，无论它们是在哪个包中, 但如果子类与父类不在同一个包中，在子类中用父类的实例去访问的话不可以。\n   名称 说明 备注     public 可以被任何类访问    protected 可以被同一包中的所有类访问 子类没有在同一包中也可以访问   private 只能够被 当前类的方法访问    缺省无访问修饰符 只能够被 当前类的方法访问 如果子类没有在同一个包中，也不能访问    数据类型 八种基本数据类型：整型（byte8、short16、int32、long64)、浮点型（float32、double63）、布尔型（boolean8）、字符型（char16）。\n自动转换顺序 从低到高的顺序转换。不同类型数据间的优先关系如下： 低\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026gt;高 byte,short,char-\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double\n“ 除了long和double类型，Java基本数据类型都是的简单读写都是原子的，而简单读写就是赋值和return语句。”因此而对于其他自加自减以及其他运算操作，是非原子操作。基本类型的数据对于其他线程来说不能保证是最新修改值，因此，声明为volative可以保证可视性。\n对于32位操作系统来说，单次操作能处理的最长长度为32bit，而long类型8字节64bit，所以对long的读写都要两条指令才能完成（即每次读写64bit中的32bit）。如果JVM要保证long和double读写的原子性，势必要做额外的处理。不加volatile的话 ，并发情况下针对某个元素的访问可能出现脏读(cpu cache导致的)，单纯的替换如果允许脏读的话 ，可以不加这些修饰符 ，如果涉及到非幂等操作 ，还是要用同步修饰符。\nInteger的缓存机制 缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。 缓存通过一个for循环实现。从低到高并创建尽可能多的整数并存储在一个整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。Java 5范围是固定的-128 至 +127。Java 6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？\nByte, Short, Long有固定范围: -128 到 127。对于Character, 范围是 0 到 127。除了Integer以外，这个范围都不能改变。\n字符串的不可变性 String s1 = \u0026#34;asd\u0026#34;;//s1保存String对象的引用 String s2 = s1;//s2保存为s1的引用 s1 = s1.replace(\u0026#34;a\u0026#34;, \u0026#34;asd\u0026#34;);//保存新创建对象的引用 repalce源码，每次都产生一个新的String对象\npublic String replace(char oldChar, char newChar) { if (oldChar != newChar) { int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i \u0026lt; len) { if (val[i] == oldChar) { break; } } if (i \u0026lt; len) { char buf[] = new char[len]; for (int j = 0; j \u0026lt; i; j++) { buf[j] = val[j]; } while (i \u0026lt; len) { char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; } return new String(buf, true);//构造新的String对象  } } return this; } String拼接 String s = \u0026quot;a\u0026quot; + \u0026quot;b\u0026quot;，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = \u0026ldquo;ab\u0026rdquo;。\n对于能够进行优化的(String s = \u0026ldquo;a\u0026rdquo; + 变量 等)底层是StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())，Java本身是不支持运算符重载的。\n对于Java的字符串拼接从效率比较：\nStringBuilder\u0026gt;StringBuffer（synchronized）\u0026gt;concat\u0026gt;+\u0026gt;StringUtils.join\nArrays.asList获得的List使用时需要注意什么  asList 得到的只是一个 Arrays 的内部类，一个原来数组的视图 List，因此如果对它进行增删操作会报错 用 ArrayList 的构造器可以将其转变成真正的 ArrayList  fail-fast和fail-safe Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程 1、线程2），线程 1 通过 Iterator 在遍历集合 A 中的元素，在某个时候线程 2 修改了集合 A 的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常。\n例子：\nList\u0026lt;String\u0026gt; fruits = new ArrayList\u0026lt;String\u0026gt;() {{ add(\u0026#34;apple\u0026#34;); add(\u0026#34;orange\u0026#34;); add(\u0026#34;orange\u0026#34;); add(\u0026#34;chestnut\u0026#34;); }}; for (String fruit : fruits) { if (fruit.equals(\u0026#34;orange\u0026#34;)) { fruits.remove(fruit); } } System.out.println(fruits.toString()); 代码抛出CMException异常，在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改。\njava.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。\n例子：\nList\u0026lt;String\u0026gt; fruits = new CopyOnWriteArrayList\u0026lt;String\u0026gt;() {{ add(\u0026#34;apple\u0026#34;); add(\u0026#34;orange\u0026#34;); add(\u0026#34;orange\u0026#34;); add(\u0026#34;chestnut\u0026#34;); }}; for (String fruit : fruits) { if (fruit.equals(\u0026#34;orange\u0026#34;)) { fruits.remove(fruit); } } System.out.println(fruits.toString()); 以上代码，使用CopyOnWriteArrayList代替了ArrayList，就不会发生异常。\nfail-safe集合的所有对集合的修改都是先拷贝一份副本，然后在副本集合上进行的，并不是直接对原集合进行修改。并且这些修改方法，如add/remove都是通过加锁来控制并发的。 所以，CopyOnWriteArrayList中的迭代器在迭代的过程中不需要做fail-fast的并发检测。（因为fail-fast的主要目的就是识别并发，然后通过异常的方式通知用户）。\nCopy-On-Write Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。\nCopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。\nCopyOnWriteArrayList中add/remove等写方法是需要加锁的，目的是为了避免Copy出N个副本出来，导致并发写。读方法未加锁，这样做的好处是我们可以对CopyOnWrite容器进行并发的读，当然，这里读到的数据可能不是最新的。因为写时复制的思想是通过延时更新的策略来实现数据的最终一致性的，并非强一致性。\nCopyOnWrite容器是一种读写分离的思想，读和写不同的容器。而Vector在读写的时候使用同一个容器，读写互斥，同时只能做一件事儿。\nCopyOnWrite并发容器用于读多写少的并发场景：白名单、黑名单、商品类目的访问和更新场景。\n和ArrayList比较，它具有以下特性：\n支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照\n迭代器 Iterator接口中提供了很多对集合元素迭代的方法。每个集合中都有可以返回迭代器对象的方法iterator()。迭代器在迭代的过程中可以删除底层集合的元素。\nIterator和ListIterator的区别？  Iterator可以用来遍历Set和List集合，但是ListIterator只能遍历List Iterator对集合只能向前遍历（next()）；而ListIterator可以向前遍历（next()），也可以向后遍历（previous()） ListIterator实现了Iterator接口  IO流 BIO、NIO和AIO \u0026mdash; 待续\n参考 Java工程师成神之路（2019正式版）\n","permalink":"https://razielez.github.io/posts/java%E5%A4%8D%E4%B9%A0%E4%B8%80/","summary":"Java基础 面向对象六原则一法则 单一职责原则（Single-Resposibility Principle） 一个类只做它该做的事情。（单一职责原则想表达的就是\u0026quot;高内聚\u0026quot;，写代码最终极的原则只有六个字\u0026quot;高内聚、低耦合\u0026quot;，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）。\n开放封闭原则（Open-Closed principle） 软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：1. 抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；2. 封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性）\nLiskov替换原则（Liskov-Substituion Principle） 里氏替换原则，任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）\n依赖倒置原则（Dependecy-Inversion Principle） 面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）\n接口隔离原则（Interface-Segregation Principle） 接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、 分离的手段主要有以下两种：1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。\n合成聚合复用原则 优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）\n迪米特法则 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。\nJava如何实现的平台无关  Java语言规范  通过规定Java语言中基本数据类型的取值范围和行为   Class文件  所有Java文件要编译成统一的Class文件   Java虚拟机  通过Java虚拟机将Class文件转成对应平台的二进制文件等    JVM支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）\n值传递、引用传递 Java中只有值传递\npublic class Main { public static void main(String[] args) { int a = 10; Integer b = 20; int[] arr = {1, 2}; swap(a, b); System.","title":"Java基础复习（一）"},{"content":" 设计模式复习 23种设计模式主要分为三类：创建型模式、结构型模式、行为型模式。\n创建型模式 单例模式  实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。\n 代码实现  饿汉式 线程安全  class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 懒汉式 双向检查锁定  class Singleton { // volatile 多线程安全, 但屏蔽Java虚拟机优化, 效率降低  private volatile static Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { // 锁定代码块  synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; } } 使用静态内部类实现  // IoDH 初始化不会失败使用, 延迟加载 public class Singleton { private static class SingletonHolder { private static final Singleton instance = new Singleton(); } public static Singleton getInstance(){ return SingletonHolder.instance; } private Singleton() {} } 使用枚举类型  public enum Singleton{ INSTANCE; } 枚举类反编译之后会被转换成形如public final class T extends Enum的定义。枚举中的各个枚举项通过static来定义。\n一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的（因为虚拟机在加载枚举的类的时候，会使用ClassLoader的loadClass方法，而这个方法使用同步代码块保证了线程安全），所以枚举类是线程安全的。\n结构型模式 代理模式  给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问，必须经过代理才能访问被代理对象。在应用场景上不同于装饰者模式，更偏向于代理的含义，代理模式重点在于控制对象的行为，而装饰模式侧重于增加对象的职能，为对象增加额外的职能。\n 结构如下：\nJava中实现动态代理 Java中代理模式有动态代理、静态代理、Cglib代理。\nJava中实现动态代理的步骤： 1.定义一个委托类和公共接口。\n2.自己定义一个类（调用处理器类，即实现 InvocationHandler 接口），这个类的目的是指定运行时将生成的代理类需要完成的具体任务（包括Preprocess和Postprocess），即代理类调用任何方法都会经过这个调用处理器类\n3.生成代理对象（当然也会生成代理类），需要为他指定(1)委托对象(2)实现的一系列接口(3)调用处理器类的实例。因此可以看出一个代理对象对应一个委托对象，对应一个调用处理器实例。\n4.Java 实现动态代理主要涉及以下几个类：\n  java.lang.reflect.Proxy: 这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类，即 DynamicProxyClass extends Proxy。\n  java.lang.reflect.InvocationHandler: 这里称他为\u0026quot;调用处理器\u0026quot;，他是一个接口，我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口。\n  例子：\n/** * 接口 */ interface Subject { void request(); } public class DynamicProxyDemo01 { public static void main(String[] args) { RealSubject realSubject = new RealSubject();//1.创建委托对象  ProxyHandler handler = new ProxyHandler(realSubject);//2.创建调用处理器对象  //3.动态生成代理对象  Subject proxySubject = (Subject) Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); proxySubject.request(); //4.通过代理对象调用方法  } } /** * 委托类 */ class RealSubject implements Subject { public void request() { System.out.println(\u0026#34;Real Subject Request\u0026#34;); } } /** * 代理类的调用处理器 */ class ProxyHandler implements InvocationHandler { private Subject subject; public ProxyHandler(Subject subject) { this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作  System.out.println(\u0026#34;====before====\u0026#34;); Object result = method.invoke(subject, args); System.out.println(\u0026#34;====after====\u0026#34;); return result; } } 行为型模式 观察者模式 观察者模式优点：\n观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体观察者列表，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。\n观察者模式缺点：\n如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。\n如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察者模式是要特别注意这一点。\n如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。\n虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。\n策略模式  策略模式也叫政策模式，是一种行为型设计模式，是一种比较简单的设计模式。策略模式采用了面向对象的继承和多态机制。\n 策略模式适合使用在：1.多个类只有在算法或行为上稍有不同的场景。2.算法需要自由切换的场景。3.需要屏蔽算法规则的场景。\n使用策略模式当然也有需要注意的地方，那么就是策略类不要太多，如果一个策略家族的具体策略数量超过4个，则需要考虑混合模式，解决策略类膨胀和对外暴露问题。在实际项目中，我们一般通过工厂方法模式来实现策略类的声明。\n优点：1.算法可以自由切换。2.避免使用多重条件判断。3.扩展性良好。\n参考  为什么我墙裂建议大家使用枚举来实现单例。 代理模式及Java实现动态代理  ","permalink":"https://razielez.github.io/posts/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/","summary":"设计模式复习 23种设计模式主要分为三类：创建型模式、结构型模式、行为型模式。\n创建型模式 单例模式  实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。\n 代码实现  饿汉式 线程安全  class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 懒汉式 双向检查锁定  class Singleton { // volatile 多线程安全, 但屏蔽Java虚拟机优化, 效率降低  private volatile static Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { // 锁定代码块  synchronized (Singleton.","title":"设计模式复习"},{"content":"排序比较 快速排序 /** * 快速排序算法 */ public static void quickSort(int[] list, int left, int right) { if (left \u0026lt; right) { // 分割数组，找到分割点  int point = partition(list, left, right); // 递归调用，对左子数组进行快速排序  quickSort(list, left, point - 1); // 递归调用，对右子数组进行快速排序  quickSort(list, point + 1, right); } } /** * 分割数组，找到分割点 */ public static int partition(int[] list, int left, int right) { // 用数组的第一个元素作为基准数  int first = list[left]; while (left \u0026lt; right) { while (left \u0026lt; right \u0026amp;\u0026amp; list[right] \u0026gt;= first) { right--; } // 交换  swap(list, left, right); while (left \u0026lt; right \u0026amp;\u0026amp; list[left] \u0026lt;= first) { left++; } // 交换  swap(list, left, right); } // 返回分割点所在的位置  return left; } /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int left, int right) { int temp; if (list != null \u0026amp;\u0026amp; list.length \u0026gt; 0) { temp = list[left]; list[left] = list[right]; list[right] = temp; } } 希尔排序 /** * 希尔排序算法 */ public static void shellSort(int[] list) { int len = list.length ; // 取增量  int gap = len / 2; while (gap \u0026gt;= 1) { // 无序序列  for (int i = gap; i \u0026lt; len; i++) { int temp = list[i]; int j; // 有序序列  for (j = i - gap; j \u0026gt;= 0 \u0026amp;\u0026amp; list[j] \u0026gt; temp; j = j - gap) { list[j + gap] = list[j]; } list[j + gap] = temp; } // 缩小增量  gap = gap / 2; } } 堆排序 /** * 堆排序算法 */ public static void heapSort(int[] list) { // 将无序堆构造成一个大根堆，大根堆有length/2个父节点  for (int i = list.length / 2 - 1; i \u0026gt;= 0; i--) { headAdjust(list, i, list.length); } // 逐步将每个最大值的根节点与末尾元素交换，并且再调整其为大根堆  for (int i = list.length - 1; i \u0026gt; 0; i--) { // 将堆顶节点和当前未经排序的子序列的最后一个元素交换位置  swap(list, 0, i); headAdjust(list, 0, i); } } /** * 构造大根堆 */ public static void headAdjust(int[] list, int parent, int length) { // 保存当前父节点  int temp = list[parent]; // 得到左孩子节点  int leftChild = 2 * parent + 1; while (leftChild \u0026lt; length) { // 如果parent有右孩子，则要判断左孩子是否小于右孩子  if (leftChild + 1 \u0026lt; length \u0026amp;\u0026amp; list[leftChild] \u0026lt; list[leftChild + 1]) { leftChild++; } // 父亲节点大于子节点，就不用做交换  if (temp \u0026gt;= list[leftChild]) { break; } // 将较大子节点的值赋给父亲节点  list[parent] = list[leftChild]; // 然后将子节点做为父亲节点  parent = leftChild; // 找到该父亲节点较小的左孩子节点  leftChild = 2 * parent + 1; } // 最后将temp值赋给较大的子节点，以形成两值交换  list[parent] = temp; } /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int top, int last) { int temp = list[top]; list[top] = list[last]; list[last] = temp; } 归并排序 /** * 归并排序算法 * @param list 待排序的列表 * @param tempList 临时列表 * @param head 列表开始位置 * @param rear 列表结束位置 */ public static void mergeSort(int[] list, int[] tempList, int head, int rear) { if (head \u0026lt; rear) { // 取分割位置  int middle = (head + rear) / 2; // 递归划分列表的左序列  mergeSort(list, tempList, head, middle); // 递归划分列表的右序列  mergeSort(list, tempList, middle + 1, rear); // 列表的合并操作  merge(list, tempList, head, middle + 1, rear); } } /** * 合并操作(列表的两两合并) * @param list * @param tempList * @param head * @param middle * @param rear */ public static void merge(int[] list, int[] tempList, int head, int middle, int rear) { // 左指针尾  int headEnd = middle - 1; // 右指针头  int rearStart = middle; // 临时列表的下标  int tempIndex = head; // 列表合并后的长度  int tempLength = rear - head + 1; // 先循环两个区间段都没有结束的情况  while ((headEnd \u0026gt;= head) \u0026amp;\u0026amp; (rearStart \u0026lt;= rear)) { // 如果发现右序列大，则将此数放入临时列表  if (list[head] \u0026lt; list[rearStart]) { tempList[tempIndex++] = list[head++]; } else { tempList[tempIndex++] = list[rearStart++]; } } // 判断左序列是否结束  while (head \u0026lt;= headEnd) { tempList[tempIndex++] = list[head++]; } // 判断右序列是否结束  while (rearStart \u0026lt;= rear) { tempList[tempIndex++] = list[rearStart++]; } // 交换数据  for (int i = 0; i \u0026lt; tempLength; i++) { list[rear] = tempList[rear]; rear--; } } 直接选择排序 /** * 直接选择排序算法 */ public static void selectionSort(int[] list) { int len = list.length ; // 要遍历的次数（length-1次）  for (int i = 0; i \u0026lt; len - 1; i++) { // 将当前下标定义为最小值下标  int min = i; // 遍历min后面的数据  for (int j = i + 1; j \u0026lt;= len - 1; j++) { // 如果有小于当前最小值的元素，将它的下标赋值给min  if (list[j] \u0026lt; list[min]) { min = j; } } // 如果min不等于i，说明找到真正的最小值  if (min != i) { swap(list, min, i); } } } /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int min, int i) { int temp = list[min]; list[min] = list[i]; list[i] = temp; } 直接插入排序 /** * 直接插入排序算法 */ public static void insertSort(int[] list) { int len = list.length ; // 从无序序列中取出第一个元素 (注意无序序列是从第二个元素开始的)  for (int i = 1; i \u0026lt; len; i++) { int temp = list[i]; int j; // 遍历有序序列  // 如果有序序列中的元素比临时元素大，则将有序序列中比临时元素大的元素依次后移  for (j = i - 1; j \u0026gt;= 0 \u0026amp;\u0026amp; list[j] \u0026gt; temp; j--) { list[j + 1] = list[j]; } // 将临时元素插入到腾出的位置中  list[j + 1] = temp; } } 冒泡排序 /** * 冒泡排序算法 */ public static void bubbleSort(int[] list) { int len = list.length ; // 做多少轮排序（最多length-1轮）  for (int i = 0; i \u0026lt; len - 1; i++) { // 每一轮比较多少个  for (int j = 0; j \u0026lt; len - 1 - i; j++) { if (list[j] \u0026gt; list[j + 1]) { // 交换次序  int temp = list[j]; list[j] = list[j + 1]; list[j + 1] = temp; } } } } ","permalink":"https://razielez.github.io/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/","summary":"排序比较 快速排序 /** * 快速排序算法 */ public static void quickSort(int[] list, int left, int right) { if (left \u0026lt; right) { // 分割数组，找到分割点  int point = partition(list, left, right); // 递归调用，对左子数组进行快速排序  quickSort(list, left, point - 1); // 递归调用，对右子数组进行快速排序  quickSort(list, point + 1, right); } } /** * 分割数组，找到分割点 */ public static int partition(int[] list, int left, int right) { // 用数组的第一个元素作为基准数  int first = list[left]; while (left \u0026lt; right) { while (left \u0026lt; right \u0026amp;\u0026amp; list[right] \u0026gt;= first) { right--; } // 交换  swap(list, left, right); while (left \u0026lt; right \u0026amp;\u0026amp; list[left] \u0026lt;= first) { left++; } // 交换  swap(list, left, right); } // 返回分割点所在的位置  return left; } /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int left, int right) { int temp; if (list !","title":"常见排序算法实现"},{"content":" 思路  分析页面结构, 问题标号: q+第几题, 问题选项: q+第几题+_第几个选项.    对一次提交进行抓包, 抓取post数据包. 对submidata进行解码得到如下. 明显看出是题号$选项号}组成的.\n  写python脚本构造post请求.利用X-Forwarded-For绕过服务器IP地址过滤.\n  import requests from time import * from random import randint for i in range(10): header = { \u0026#39;Host\u0026#39;: \u0026#39;www.wjx.cn\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0\u0026#39;, \u0026#39;X-Forwarded-For\u0026#39;: str(randint(1, 255)) + \u0026#39;.\u0026#39; + str(randint(1, 255)) + \u0026#39;.\u0026#39; + str(randint(1, 255)) + \u0026#39;.\u0026#39; + str( randint(1, 255)), \u0026#39;Referer\u0026#39;: \u0026#39;https://www.wjx.cn###.aspx\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;acw_tc=2f624a1f154##\u0026#39;, } print(\u0026#34;第 \u0026#34; + str(i) + \u0026#34; 提交\u0026#34; + \u0026#34; Using IP:\u0026#34; + header[\u0026#39;X-Forwarded-For\u0026#39;] + \u0026#39; to compalte this Q.\u0026#39;) data = \u0026#34;submitdata=1$%s}2$%s}3$%s}4$%s}5$%s}6$%s}7$%s}8$3}9$-3}10$-3}11$%s}12$%s}13$%s}14$%s}15$%s}16$%s}17$%s}18$%s\u0026#34; % ( str(randint(1, 7)), str(randint(1, 9)), str(randint(1, 4)), str(randint(1, 3)), str(randint(1, 4)), str(randint(1, 3)), str(randint(1, 3)), str(randint(1, 2)), str(randint(1, 2)), str(randint(1, 4)), str(randint(1, 2)), str(randint(1, 2)), str(randint(1, 3)), str(randint(1, 2)), str(randint(1, 3))) url = \u0026#39;https://www.wjx.cn/joinnew/processjq.ashx?curid=34131883\u0026amp;starttime=2019%2F1%2F25%2021%3A37%3A12\u0026amp;source=directphone\u0026amp;submittype=1\u0026amp;ktimes=213\u0026amp;hlv=1\u0026amp;rn=1034449004.44465961\u0026amp;t=1548423507485\u0026amp;jqnonce=c5825f6b-67d7-40c8-ba2e-e1ffb82c4642\u0026amp;jqsign=%606%3B16e5a.54g4.73%60%3B.ab1f.f2eea%3B1%607571\u0026#39; r = requests.post(url, data=data, headers=header) # print(r) print(\u0026#34;Complate.\u0026#34;) ","permalink":"https://razielez.github.io/posts/%E9%97%AE%E5%8D%B7%E6%98%9F%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC/","summary":"思路  分析页面结构, 问题标号: q+第几题, 问题选项: q+第几题+_第几个选项.    对一次提交进行抓包, 抓取post数据包. 对submidata进行解码得到如下. 明显看出是题号$选项号}组成的.\n  写python脚本构造post请求.利用X-Forwarded-For绕过服务器IP地址过滤.\n  import requests from time import * from random import randint for i in range(10): header = { \u0026#39;Host\u0026#39;: \u0026#39;www.wjx.cn\u0026#39;, \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0\u0026#39;, \u0026#39;X-Forwarded-For\u0026#39;: str(randint(1, 255)) + \u0026#39;.\u0026#39; + str(randint(1, 255)) + \u0026#39;.\u0026#39; + str(randint(1, 255)) + \u0026#39;.\u0026#39; + str( randint(1, 255)), \u0026#39;Referer\u0026#39;: \u0026#39;https://www.wjx.cn###.aspx\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;acw_tc=2f624a1f154##\u0026#39;, } print(\u0026#34;第 \u0026#34; + str(i) + \u0026#34; 提交\u0026#34; + \u0026#34; Using IP:\u0026#34; + header[\u0026#39;X-Forwarded-For\u0026#39;] + \u0026#39; to compalte this Q.","title":"问卷星自动提交脚本"},{"content":" 题目 求解字符串最长回文串。\nleetcode: 最长回文子串\n样例 Input 121\r1\rdaccbba\rbb\rOutput 121\r1\raccbba\rbb\rManacher算法，时间复杂度O(n), 空间复杂度O(1)。\n步骤 先对s串处理转换为奇数长度的串。\ns = \u0026quot;12212321\u0026quot;\r==\u0026gt;\rS # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #\rP 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1\rp[i]表示记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。 即以i为原点的最大回文半径。\nManacher算法增加两个辅助变量id和mx。\nid代表当前“已经匹配完毕的结尾最远的回文串”中心为s的第ID位。\nmx = p[i] + id代表当前“已经匹配完毕的结尾最远的回文串”到达了s的第Mx位。\n最长回文子串长度 = p[i] - 1 = 5。\n2*id - i是i关于id的对称点\n故p[i] = min(p[2*id-i], mx-i)\n主要代码：\n//对s进行修改 ... for (i = 1; i \u0026lt; s.length()-1; i++) { p[i] = mx \u0026gt; i ? min(p[2 * id - i], mx - i) : 1; while (s[i + p[i]] == s[i - p[i]]) p[i]++; if (i + p[i] \u0026gt; mx) { mx = i + p[i]; id = i; } } ... // 求结果串 ac代码：\nipublic class Main { public static void main(String[] args) throws InterruptedException { String s = \u0026#34;12212321\u0026#34;; } } class Solution { private static String preProcess(String s) { int n = s.length(); if (n == 0) { return \u0026#34;^$\u0026#34;; } StringBuilder ret = new StringBuilder(\u0026#34;^\u0026#34;); for (int i = 0; i \u0026lt; n; i++) ret.append(\u0026#34;#\u0026#34;).append(s.charAt(i)); ret.append(\u0026#34;#$\u0026#34;); return ret.toString(); } public String longestPalindrome(String s) { String t = s; s = preProcess(s); int n = s.length(); int[] p = new int[n]; int mx = 0, id = 0; for (int i = 1; i \u0026lt; n - 1; i++) { p[i] = (mx \u0026gt; i) ? Math.min(p[2 * id - i], mx - i) : 1; while (s.charAt(i + p[i]) == s.charAt(i - p[i])) { p[i]++; } if (i + p[i] \u0026gt; mx) { mx = i + p[i]; id = i; } } int maxLen = 0; int centerIndex = 0; for (int i = 1; i \u0026lt; p.length - 1; i++) { if (p[i] \u0026gt; maxLen) { maxLen = p[i]; centerIndex = i; } } int start = (centerIndex - maxLen) / 2; return t.substring(start, start + maxLen - 1); } } 参考 Manacher算法\n","permalink":"https://razielez.github.io/posts/manacher-%E5%9B%9E%E6%96%87%E4%B8%B2/","summary":"题目 求解字符串最长回文串。\nleetcode: 最长回文子串\n样例 Input 121\r1\rdaccbba\rbb\rOutput 121\r1\raccbba\rbb\rManacher算法，时间复杂度O(n), 空间复杂度O(1)。\n步骤 先对s串处理转换为奇数长度的串。\ns = \u0026quot;12212321\u0026quot;\r==\u0026gt;\rS # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #\rP 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1\rp[i]表示记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。 即以i为原点的最大回文半径。\nManacher算法增加两个辅助变量id和mx。\nid代表当前“已经匹配完毕的结尾最远的回文串”中心为s的第ID位。\nmx = p[i] + id代表当前“已经匹配完毕的结尾最远的回文串”到达了s的第Mx位。\n最长回文子串长度 = p[i] - 1 = 5。","title":"Manacher算法-最长回文串"},{"content":" 一、删库 。。。。\n二、使用BFG Repo-Cleaner 地址： BFG Repo-Cleaner\n简单使用 #克隆副本\rgit clone --mirror git://example.com/example.git\r#清理分支\rjava -jar bfg-1.13.0.jar --replace-text pwd.txt example.git\rcd example.git \u0026amp; git reflog expire --expire=now --all \u0026amp;\u0026amp; git gc --prune=now --aggressive \u0026amp; git push\rgit 取消对某个文件的track .gitignore无法对已经track的文件忽略\ngit rm --cached example.files\rgit commit\rgit push\r","permalink":"https://razielez.github.io/posts/%E6%B8%85%E9%99%A4%E6%8F%90%E4%BA%A4%E5%88%B0github%E4%B8%8A%E7%9A%84%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81/","summary":" 一、删库 。。。。\n二、使用BFG Repo-Cleaner 地址： BFG Repo-Cleaner\n简单使用 #克隆副本\rgit clone --mirror git://example.com/example.git\r#清理分支\rjava -jar bfg-1.13.0.jar --replace-text pwd.txt example.git\rcd example.git \u0026amp; git reflog expire --expire=now --all \u0026amp;\u0026amp; git gc --prune=now --aggressive \u0026amp; git push\rgit 取消对某个文件的track .gitignore无法对已经track的文件忽略\ngit rm --cached example.files\rgit commit\rgit push\r","title":"清除提交到github上的账号密码"},{"content":"代码示例： public class Java8Stream { public static void main(String args[]) { System.out.println(\u0026#34;使用 Java 7: \u0026#34;); // 计算空字符串  List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026#34;abc\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;bc\u0026#34;, \u0026#34;efg\u0026#34;, \u0026#34;abcd\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;jkl\u0026#34;); System.out.println(\u0026#34;列表: \u0026#34; + strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(\u0026#34;空字符数量为: \u0026#34; + count); count = getCountLength3UsingJava7(strings); System.out.println(\u0026#34;字符串长度为 3 的数量为: \u0026#34; + count); // 删除空字符串  List\u0026lt;String\u0026gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(\u0026#34;筛选后的列表: \u0026#34; + filtered); // 删除空字符串，并使用逗号把它们合并起来  String mergedString = getMergedStringUsingJava7(strings, \u0026#34;, \u0026#34;); System.out.println(\u0026#34;合并字符串: \u0026#34; + mergedString); List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取列表元素平方数  List\u0026lt;Integer\u0026gt; squaresList = getSquares(numbers); System.out.println(\u0026#34;平方数列表: \u0026#34; + squaresList); List\u0026lt;Integer\u0026gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19); System.out.println(\u0026#34;列表: \u0026#34; + integers); System.out.println(\u0026#34;列表中最大的数 : \u0026#34; + getMax(integers)); System.out.println(\u0026#34;列表中最小的数 : \u0026#34; + getMin(integers)); System.out.println(\u0026#34;所有数之和 : \u0026#34; + getSum(integers)); System.out.println(\u0026#34;平均数 : \u0026#34; + getAverage(integers)); System.out.println(\u0026#34;随机数: \u0026#34;); // 输出10个随机数  Random random = new Random(); for (int i = 0; i \u0026lt; 10; i++) { System.out.println(random.nextInt()); } System.out.println(\u0026#34;使用 Java 8: \u0026#34;); System.out.println(\u0026#34;列表: \u0026#34; + strings); count = strings.stream().filter(string -\u0026gt; string.isEmpty()).count(); System.out.println(\u0026#34;空字符串数量为: \u0026#34; + count); count = strings.stream().filter(string -\u0026gt; string.length() == 3).count(); System.out.println(\u0026#34;字符串长度为 3 的数量为: \u0026#34; + count); filtered = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(\u0026#34;筛选后的列表: \u0026#34; + filtered); mergedString = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.joining(\u0026#34;, \u0026#34;)); System.out.println(\u0026#34;合并字符串: \u0026#34; + mergedString); squaresList = numbers.stream().map(i -\u0026gt; i * i).distinct().collect(Collectors.toList()); System.out.println(\u0026#34;Squares List: \u0026#34; + squaresList); System.out.println(\u0026#34;列表: \u0026#34; + integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -\u0026gt; x).summaryStatistics(); System.out.println(\u0026#34;列表中最大的数 : \u0026#34; + stats.getMax()); System.out.println(\u0026#34;列表中最小的数 : \u0026#34; + stats.getMin()); System.out.println(\u0026#34;所有数之和 : \u0026#34; + stats.getSum()); System.out.println(\u0026#34;平均数 : \u0026#34; + stats.getAverage()); System.out.println(\u0026#34;随机数: \u0026#34;); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理  count = strings.parallelStream().filter(string -\u0026gt; string.isEmpty()).count(); System.out.println(\u0026#34;空字符串的数量为: \u0026#34; + count); } private static int getCountEmptyStringUsingJava7(List\u0026lt;String\u0026gt; strings) { int count = 0; for (String string : strings) { if (string.isEmpty()) { count++; } } return count; } private static int getCountLength3UsingJava7(List\u0026lt;String\u0026gt; strings) { int count = 0; for (String string : strings) { if (string.length() == 3) { count++; } } return count; } private static List\u0026lt;String\u0026gt; deleteEmptyStringsUsingJava7(List\u0026lt;String\u0026gt; strings) { List\u0026lt;String\u0026gt; filteredList = new ArrayList\u0026lt;String\u0026gt;(); for (String string : strings) { if (!string.isEmpty()) { filteredList.add(string); } } return filteredList; } private static String getMergedStringUsingJava7(List\u0026lt;String\u0026gt; strings, String separator) { StringBuilder stringBuilder = new StringBuilder(); for (String string : strings) { if (!string.isEmpty()) { stringBuilder.append(string); stringBuilder.append(separator); } } String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length() - 2); } private static List\u0026lt;Integer\u0026gt; getSquares(List\u0026lt;Integer\u0026gt; numbers) { List\u0026lt;Integer\u0026gt; squaresList = new ArrayList\u0026lt;Integer\u0026gt;(); for (Integer number : numbers) { Integer square = new Integer(number.intValue() * number.intValue()); if (!squaresList.contains(square)) { squaresList.add(square); } } return squaresList; } private static int getMax(List\u0026lt;Integer\u0026gt; numbers) { int max = numbers.get(0); for (int i = 1; i \u0026lt; numbers.size(); i++) { Integer number = numbers.get(i); if (number.intValue() \u0026gt; max) { max = number.intValue(); } } return max; } private static int getMin(List\u0026lt;Integer\u0026gt; numbers) { int min = numbers.get(0); for (int i = 1; i \u0026lt; numbers.size(); i++) { Integer number = numbers.get(i); if (number.intValue() \u0026lt; min) { min = number.intValue(); } } return min; } private static int getSum(List numbers) { int sum = (int) (numbers.get(0)); for (int i = 1; i \u0026lt; numbers.size(); i++) { sum += (int) numbers.get(i); } return sum; } private static int getAverage(List\u0026lt;Integer\u0026gt; numbers) { return getSum(numbers) / numbers.size(); } } ","permalink":"https://razielez.github.io/posts/java8-stream/","summary":"代码示例： public class Java8Stream { public static void main(String args[]) { System.out.println(\u0026#34;使用 Java 7: \u0026#34;); // 计算空字符串  List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026#34;abc\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;bc\u0026#34;, \u0026#34;efg\u0026#34;, \u0026#34;abcd\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;jkl\u0026#34;); System.out.println(\u0026#34;列表: \u0026#34; + strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(\u0026#34;空字符数量为: \u0026#34; + count); count = getCountLength3UsingJava7(strings); System.out.println(\u0026#34;字符串长度为 3 的数量为: \u0026#34; + count); // 删除空字符串  List\u0026lt;String\u0026gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(\u0026#34;筛选后的列表: \u0026#34; + filtered); // 删除空字符串，并使用逗号把它们合并起来  String mergedString = getMergedStringUsingJava7(strings, \u0026#34;, \u0026#34;); System.out.println(\u0026#34;合并字符串: \u0026#34; + mergedString); List\u0026lt;Integer\u0026gt; numbers = Arrays.","title":"Java8 Stream"},{"content":"Java8 引入了新的时间类 使用 LocalDate 和 LocalTime 创建 LocalDate 对象并读取值\n//2013-03-06 LocalDate date = LocalDate.of(2012,03,06); //2012 int year = date.getYear(); //MARCH Month month = date.getMonth(); //TUESDAY DayOfWeek dow = date.getDayOfWeek(); //6 int day = date.getDayOfMonth(); //31 int len = date.lengthOfMonth(); //false boolean leap = date.isLeapYear(); //使用工厂方法获取系统日期 LocalDate today = LocalDate.now(); LocalTime time = LocalTime.now().withNano(0);//去除毫秒 TemporalField 是一个接口, 定义了如何访问 temporal 对象某个字段的值. ChronoField 枚举实现这一接口.\nint year = date.get(ChronoField.YEAR); int month = date.get(ChronoField.MONTH_OF_YEAR); int day = date.get(ChronoField.DAY_OF_MONTH); LocalDate 和 LocalTime 都可以解析字符串创建.\nLocalDate date = LocalDate.parse(\u0026#34;2012-12-22\u0026#34;); LocalTime time = LocalTime.parse(\u0026#34;22:22:22\u0026#34;); 操作、解析和格式化 使用 TemporalAdjuster ","permalink":"https://razielez.github.io/posts/java8-date-time-api/","summary":"Java8 引入了新的时间类 使用 LocalDate 和 LocalTime 创建 LocalDate 对象并读取值\n//2013-03-06 LocalDate date = LocalDate.of(2012,03,06); //2012 int year = date.getYear(); //MARCH Month month = date.getMonth(); //TUESDAY DayOfWeek dow = date.getDayOfWeek(); //6 int day = date.getDayOfMonth(); //31 int len = date.lengthOfMonth(); //false boolean leap = date.isLeapYear(); //使用工厂方法获取系统日期 LocalDate today = LocalDate.now(); LocalTime time = LocalTime.now().withNano(0);//去除毫秒 TemporalField 是一个接口, 定义了如何访问 temporal 对象某个字段的值. ChronoField 枚举实现这一接口.\nint year = date.get(ChronoField.YEAR); int month = date.get(ChronoField.MONTH_OF_YEAR); int day = date.","title":"Java8 Date AND Time API"},{"content":"1. request 对象常用方法 request 是来自客户端的请求. 客户端的请求信息封装在 request 对象中. 以下 HttpServletRequest 类的实例.\n   方法 ( 类型 + 方法名 ) 描述     String getParameter(String strTextName) 获取表单提交信息   Enumeration getParameterNames() 返回可用参数的枚举   String[] getParameterValues(String name) 返回包含参数 name 的所有的数组   Enumeration getAttributeNames() 返回所有属性名的属性值   Object getAttribute(String name) 返回指定属性的属性值   String getCharacterEncoding() 返回字节编码方式   String getProtocol() 获取用户使用的协议   String getServletPath() 获取用户提交信息的页面   String getMethod() 获取客户提交信息的方式   BufferReader getHeader() 获取 HTTP 头文件的 accept、accept-encoding 和 Host 的值   String getRemoteAddr() 获取客户的 IP 地址   String getRemoteHost() 获取客户机的名称   String getserverName() 获取服务器的名称   int getServerPort() 获取服务器端口号    2. resopnse 对象常用方法 resopnse 对象代表的是对客户端的相应. 向客户端发送文字时直接使用. 以下是 HttpServletResopnse 类的实例.\n   方法 ( 类型 + 方法名 ) 描述     String getCharacterEncoding() 返回响应用的是什么字符编码   ServletOutputStream getOutputStream() 返回响应的一个二进制输出流   PrintWrite getWrite() 返回可以向客户端输出字符的一个对象   void setContentLength(int len) 设置响应头长度   void setContentTye(String type) 设置响应的 MIME 类型   void sendRedirect(Java.lang.String location) 重新定向客户端的请求    3. session 常用方法 session 指的是客户端与服务器的一次回话, 从客户连接到服务器的一个 WebApplication 开始, 直到客户端与服务器断开连接为止. 它是 HttpSession 类的实例.\n   方法 ( 类型 + 方法名 ) 描述     long getCreationTime() 创建 session 创建时间   public String getId() 返回 session 创建时JSP引擎为它设置的唯一ID号   long getLastAccessedTime() 返回 session 里客户端最近一次请求时间   int getMaxInactiveInterval() 返回两次请求间隔多长时间此 session 被取消   String[] getValueNames() 返回一个包含此 session 中所有可用属性的数组   void invalidate() 取消 session , 使 session 不可用   boolean isNew() 返回服务器创建爱你的一个 session , 客户端是否已经加入   void removeValue(String name) 删除 session 中指定的属性   void setMaxInactiveInterval() session 被取消 (ms)    4. out 常用方法 out 对象是 JspWriter 类的实例, 是向客户端输出内容常用的对象.\n   方法 ( 类型 + 方法名 ) 描述     void clear() 清除缓冲区的内容   void clearBuffer() 清除缓冲区的当前内容   void flush() 清空流   int getBufferSize() 返回缓冲区以字节数的大小,如果不设置为0   int getRemaining() 返回缓冲区还有多少剩余可用   bool isAutoFlush() 返回缓冲区满时,是自动清空还是抛出异常   void close() 关闭输出流    5. page 常用方法 page 指当前 JSP 页面本身, 有点像类中的 this 指针, 它是 java.langlObject 类的实例. 「page」对象代表正在运行的由 jsp 文件产生的类对象.\n   方法 ( 类型 + 方法名 ) 描述     class getClass() 返回此 Object 的类   int hashCode() 返回此 Object 的 hash 码   boolean equals(Object obj) 判断此 Object 是否与指定的 Object 对象相等   void copy(Object obj) 把此 Object 拷贝到指定的 Object 对象中   Object clone() 克隆此 Object 对象   String toString() 把此 Object 对象转换成 String 类的对象   void notify() 唤醒一个等待的进程   void notifyAll() 唤醒所有等待的进程   void wait(int timeout) 使一个进程处于等待直到 timeout 结束或者被唤醒   void wait() 使一个线程处于等待直到被唤醒   void enterMonitor() 对 Object 进行加锁   void exitMonitor() 对 Object 进行开锁    6. application 常用方法 application 实现了用户间数据的共享, 可存放全局变量. 它开始于服务器的启动, 直到服务器的关闭, 在此期间, 此对象将一直存在; 这样在用户的前后连接或者不同用户之间的连接中, 可以对此对象的同一属性进行操作; 在任何地方对此对象属性的操作, 都将影响到其他对象对此的访问. 服务器的启动和关闭决定了 application 对象的生命. 它是 ServletContest类的实例.\n","permalink":"https://razielez.github.io/posts/jsp-%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","summary":"1. request 对象常用方法 request 是来自客户端的请求. 客户端的请求信息封装在 request 对象中. 以下 HttpServletRequest 类的实例.\n   方法 ( 类型 + 方法名 ) 描述     String getParameter(String strTextName) 获取表单提交信息   Enumeration getParameterNames() 返回可用参数的枚举   String[] getParameterValues(String name) 返回包含参数 name 的所有的数组   Enumeration getAttributeNames() 返回所有属性名的属性值   Object getAttribute(String name) 返回指定属性的属性值   String getCharacterEncoding() 返回字节编码方式   String getProtocol() 获取用户使用的协议   String getServletPath() 获取用户提交信息的页面   String getMethod() 获取客户提交信息的方式   BufferReader getHeader() 获取 HTTP 头文件的 accept、accept-encoding 和 Host 的值   String getRemoteAddr() 获取客户的 IP 地址   String getRemoteHost() 获取客户机的名称   String getserverName() 获取服务器的名称   int getServerPort() 获取服务器端口号    2.","title":"JSP 九大内置对象常用方法"},{"content":"位运算 \u0026amp; 、|、 ^ a \u0026amp; a = a a | a = a a ^ a = 0 a \u0026amp; 0 = 0 a | 0 = a a ^ 0 = a a | ( a \u0026amp; b ) = a a \u0026amp; ( a | b ) = a a、b值交换 a ^= b; b ^= a; a ^= b; 判断奇偶（取最后一位） a \u0026amp; 1 \u0026lt;==\u0026gt; a % 2 i+1位置为1 // 1110 =\u0026gt; 1111 a |= 1 \u0026lt;\u0026lt; i i+1位置为0 // 1111 =\u0026gt; 1101\ra \u0026amp;= ~(1 \u0026lt;\u0026lt; i)\r取出i+1位 // i = 2, 7 =\u0026gt; 4 a = a \u0026amp; (1 \u0026lt;\u0026lt; i) 删除最后的1 // 1100 =\u0026gt; 1000 a = a \u0026amp; (a-1) 在对应i+1位，插入b的对应位 a |= 1 \u0026lt;\u0026lt; i; （a的bit位置1）\ra \u0026amp; (b \u0026amp; 1\u0026lt;\u0026lt;i) （与b的bit位相与）\r得到最高位的1 a = a |(a\u0026gt;\u0026gt;1); a = a |(a\u0026gt;\u0026gt;2); a = a |(a\u0026gt;\u0026gt;4); a = a |(a\u0026gt;\u0026gt;8); a = a |(a\u0026gt;\u0026gt;16); return (a+1)\u0026gt;\u0026gt;1; 检测一个无符号整数是否是2^n -1的形式 x\u0026amp;(x+1) 移位 在Java中正数\u0026gt;\u0026gt;等价于\u0026gt;\u0026gt;\u0026gt;，负数在内存中已补码形式保存，\u0026gt;\u0026gt;\u0026gt;表示无符号右移。\n“1”位计数 统计一个字（比如32bit）中，有多少个bit是1，有多少个bit是0。\n这里以32bit为例来说明算法，这里基本思想类似折半计算。算法复杂度O(lgn)\nx = (x \u0026amp; 0x55555555) + ((x\u0026gt;\u0026gt;1)\u0026amp; 0x55555555); x = (x \u0026amp; 0x33333333) + ((x\u0026gt;\u0026gt;2)\u0026amp; 0x33333333); x = (x \u0026amp; 0x0F0F0F0F) + ((x\u0026gt;\u0026gt;4)\u0026amp; 0x0F0F0F0F); x = (x \u0026amp; 0x00FF00FF) + ((x\u0026gt;\u0026gt;8)\u0026amp; 0x00FF00FF); x = (x \u0026amp; 0x0000FFFF) + ((x\u0026gt;\u0026gt;16)\u0026amp; 0x0000FFFF); 搜索 \u0026mdash;待续\n参考  《Hacker\u0026rsquo;s Delight》  ","permalink":"https://razielez.github.io/posts/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%94%E8%AE%B0/","summary":"位运算 \u0026amp; 、|、 ^ a \u0026amp; a = a a | a = a a ^ a = 0 a \u0026amp; 0 = 0 a | 0 = a a ^ 0 = a a | ( a \u0026amp; b ) = a a \u0026amp; ( a | b ) = a a、b值交换 a ^= b; b ^= a; a ^= b; 判断奇偶（取最后一位） a \u0026amp; 1 \u0026lt;==\u0026gt; a % 2 i+1位置为1 // 1110 =\u0026gt; 1111 a |= 1 \u0026lt;\u0026lt; i i+1位置为0 // 1111 =\u0026gt; 1101\ra \u0026amp;= ~(1 \u0026lt;\u0026lt; i)\r取出i+1位 // i = 2, 7 =\u0026gt; 4 a = a \u0026amp; (1 \u0026lt;\u0026lt; i) 删除最后的1 // 1100 =\u0026gt; 1000 a = a \u0026amp; (a-1) 在对应i+1位，插入b的对应位 a |= 1 \u0026lt;\u0026lt; i; （a的bit位置1）\ra \u0026amp; (b \u0026amp; 1\u0026lt;\u0026lt;i) （与b的bit位相与）\r得到最高位的1 a = a |(a\u0026gt;\u0026gt;1); a = a |(a\u0026gt;\u0026gt;2); a = a |(a\u0026gt;\u0026gt;4); a = a |(a\u0026gt;\u0026gt;8); a = a |(a\u0026gt;\u0026gt;16); return (a+1)\u0026gt;\u0026gt;1; 检测一个无符号整数是否是2^n -1的形式 x\u0026amp;(x+1) 移位 在Java中正数\u0026gt;\u0026gt;等价于\u0026gt;\u0026gt;\u0026gt;，负数在内存中已补码形式保存，\u0026gt;\u0026gt;\u0026gt;表示无符号右移。","title":"位运算笔记"},{"content":"懒得每天在某个网站签到，写了一个python脚本扔在云主机上。网站很简单，代码就几十行。\n签到脚本 import requests username = \u0026#34;####\u0026#34; password = \u0026#34;####\u0026#34; loginUrl = \u0026#34;登录路径/auth/login\u0026#34; s = requests.Session() logindata = { \u0026#39;email\u0026#39;:username, \u0026#39;passwd\u0026#39;:password, \u0026#39;remember_me\u0026#39;:\u0026#39;ture\u0026#39;, } r = s.post(loginUrl,data=logindata) r = s.get(loginUrl) checkinUrl=\u0026#34;签到的路径/user/checkin\u0026#34; rr = s.post(checkinUrl)#执行签到 rr = s.get(loginUrl) # print(rr) # print(rr._content.decode()) exit() 在Linux上定时执行这个脚本 crontab -e 进入编辑模式，设置每天8:00运行一次。 crontab的语法规范 分钟 小时 日期 月份 周 命令\n00 8 * * * python /opt/checkin.py\r","permalink":"https://razielez.github.io/posts/20%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E7%AD%BE%E5%88%B0%E8%84%9A%E6%9C%AC/","summary":"懒得每天在某个网站签到，写了一个python脚本扔在云主机上。网站很简单，代码就几十行。\n签到脚本 import requests username = \u0026#34;####\u0026#34; password = \u0026#34;####\u0026#34; loginUrl = \u0026#34;登录路径/auth/login\u0026#34; s = requests.Session() logindata = { \u0026#39;email\u0026#39;:username, \u0026#39;passwd\u0026#39;:password, \u0026#39;remember_me\u0026#39;:\u0026#39;ture\u0026#39;, } r = s.post(loginUrl,data=logindata) r = s.get(loginUrl) checkinUrl=\u0026#34;签到的路径/user/checkin\u0026#34; rr = s.post(checkinUrl)#执行签到 rr = s.get(loginUrl) # print(rr) # print(rr._content.decode()) exit() 在Linux上定时执行这个脚本 crontab -e 进入编辑模式，设置每天8:00运行一次。 crontab的语法规范 分钟 小时 日期 月份 周 命令\n00 8 * * * python /opt/checkin.py\r","title":"20行代码的签到脚本(Python)"},{"content":"emmm时间长忘记密码了\n执行 $ python manage.py shell 修改 In [1]: from django.contrib.auth.models import User In [2]: user = User.objects.get(username=\u0026#39;Username\u0026#39;) In [3]: user.set_password(\u0026#39;Password\u0026#39;) In [4]: user.save() In [5]: exit() ","permalink":"https://razielez.github.io/posts/django%E9%87%8D%E7%BD%AE%E5%90%8E%E5%8F%B0%E5%AF%86%E7%A0%81/","summary":"emmm时间长忘记密码了\n执行 $ python manage.py shell 修改 In [1]: from django.contrib.auth.models import User In [2]: user = User.objects.get(username=\u0026#39;Username\u0026#39;) In [3]: user.set_password(\u0026#39;Password\u0026#39;) In [4]: user.save() In [5]: exit() ","title":"Django重置后台密码"},{"content":"lambda表达式是一行函数，是函数式编程的一种特性。\npython lambda \u0026lt;参数\u0026gt;: 表达式\n\u0026gt;\u0026gt;\u0026gt; f = lambda a,b: a + b \u0026gt;\u0026gt;\u0026gt; type(f) #\u0026lt;type \u0026#39;function\u0026#39;\u0026gt; 获取整除2的数字\n\u0026gt;\u0026gt;\u0026gt; list(filter(lambda x: x%2==0, range(10))) #[0, 2, 4, 6, 8] 列表并行排序\n\u0026gt;\u0026gt;\u0026gt; list1 = [1,2,3,2,3];list2 = [9,4,3,5,6] \u0026gt;\u0026gt;\u0026gt; data = zip(list1, list2) \u0026gt;\u0026gt;\u0026gt; data = sorted(data) \u0026gt;\u0026gt;\u0026gt; list1, list2 = map(lambda t: list(t), zip(*data)) cpp c++里的形式是这样的 [capture list] (parameter list) -\u0026gt;return type {function body}\n示例 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int main() { //call the func.  auto f1 = []() { cout \u0026lt;\u0026lt; \u0026#34;test\u0026#34; \u0026lt;\u0026lt; endl; }; f1(); int y = 2; auto f2 = [y](int x) { cout \u0026lt;\u0026lt; x + y \u0026lt;\u0026lt; endl; }; f2(4); //STL  vector\u0026lt;int\u0026gt; v; for (int i = 0; i \u0026lt; 10; ++i) { v.push_back(i); } for_each(v.begin(), v.end(), [](int n) { if (n % 2 == 0) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }); return 0; } ","permalink":"https://razielez.github.io/posts/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"lambda表达式是一行函数，是函数式编程的一种特性。\npython lambda \u0026lt;参数\u0026gt;: 表达式\n\u0026gt;\u0026gt;\u0026gt; f = lambda a,b: a + b \u0026gt;\u0026gt;\u0026gt; type(f) #\u0026lt;type \u0026#39;function\u0026#39;\u0026gt; 获取整除2的数字\n\u0026gt;\u0026gt;\u0026gt; list(filter(lambda x: x%2==0, range(10))) #[0, 2, 4, 6, 8] 列表并行排序\n\u0026gt;\u0026gt;\u0026gt; list1 = [1,2,3,2,3];list2 = [9,4,3,5,6] \u0026gt;\u0026gt;\u0026gt; data = zip(list1, list2) \u0026gt;\u0026gt;\u0026gt; data = sorted(data) \u0026gt;\u0026gt;\u0026gt; list1, list2 = map(lambda t: list(t), zip(*data)) cpp c++里的形式是这样的 [capture list] (parameter list) -\u0026gt;return type {function body}\n示例 #include \u0026lt;iostream\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; int main() { //call the func.","title":"lambda表达式"},{"content":"问题描述 $ git commit On branch master Initial commit Untracked files: .gitignore Test/ blogpost/ manage.py nothing added to commit but untracked files present 文件被追踪，但是没有被添加git中\n解决 git status 列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件\n$ git add manage.py $ git add blogpost\\ $ git add Test\\ $ git add .gitignore ","permalink":"https://razielez.github.io/posts/nothing-added-to-commit-but-untracked-files-present%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","summary":"问题描述 $ git commit On branch master Initial commit Untracked files: .gitignore Test/ blogpost/ manage.py nothing added to commit but untracked files present 文件被追踪，但是没有被添加git中\n解决 git status 列出当前目录所有还没有被git管理的文件和被git管理且被修改但还未提交(git commit)的文件\n$ git add manage.py $ git add blogpost\\ $ git add Test\\ $ git add .gitignore ","title":"nothing added to commit but untracked files present解决方法"},{"content":"平均复杂度即为O(n)   next_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“下一个排列次序”；\n  prev_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“上一个排列次序”；\n  示例 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void f(vector\u0026lt;int\u0026gt; v){ for(int i=0;i\u0026lt;v.size();i++){ cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } int main() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(3); v.push_back(2); cout\u0026lt;\u0026lt;\u0026#34;原排列 ： \u0026#34;; f(v); for(int i=0;i\u0026lt;10;i++){ next_permutation(v.begin(),v.end());//升序序列 或者下一个排列次序 按照字典序生成下一个序列 \tf(v); } //for(int i=0;i\u0026lt;5;i++){ \t//\tprev_permutation(v.begin(),v.end());//降序 \t//\tf(v); \t//} \treturn 0; } ","permalink":"https://razielez.github.io/posts/c++%E6%9E%9A%E4%B8%BEnext_premutation/","summary":"平均复杂度即为O(n)   next_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“下一个排列次序”；\n  prev_permutation() 会改变区间[begin,end)内的元素次序，使它们符合“上一个排列次序”；\n  示例 #include \u0026lt;iostream\u0026gt;#include \u0026lt;algorithm\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; void f(vector\u0026lt;int\u0026gt; v){ for(int i=0;i\u0026lt;v.size();i++){ cout\u0026lt;\u0026lt;v[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; } int main() { vector\u0026lt;int\u0026gt; v; v.push_back(1); v.push_back(3); v.push_back(2); cout\u0026lt;\u0026lt;\u0026#34;原排列 ： \u0026#34;; f(v); for(int i=0;i\u0026lt;10;i++){ next_permutation(v.begin(),v.end());//升序序列 或者下一个排列次序 按照字典序生成下一个序列 \tf(v); } //for(int i=0;i\u0026lt;5;i++){ \t//\tprev_permutation(v.begin(),v.end());//降序 \t//\tf(v); \t//} \treturn 0; } ","title":"c++枚举next_premutation"},{"content":"报错信息 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解决办法 查看运行的线程 ps -A | grep apt-get # sudo kill processnumber # 关闭apt进程 我的没有发现进程， 可能是上次运行安装或更新时没有正常完成造成的\n终端输入 sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock ","permalink":"https://razielez.github.io/posts/ubuntu%E9%94%99%E8%AF%AF-could-not-get-lock-var-lib-dpkg-lock/","summary":"报错信息 E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it? 解决办法 查看运行的线程 ps -A | grep apt-get # sudo kill processnumber # 关闭apt进程 我的没有发现进程， 可能是上次运行安装或更新时没有正常完成造成的\n终端输入 sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock ","title":"Ubuntu错误-Could not get lock /var/lib/dpkg/lock"},{"content":"static bool sync_with_stdio( bool sync = true );  设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。\n遇到cin TLE时可以用于取消cin同步, 取消之后不能和 scanf，sscanf, getchar, fgets 之类同用。\n测试 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt; int main() { std::ios::sync_with_stdio(false); std::cout \u0026lt;\u0026lt; \u0026#34;a\\n\u0026#34;; std::printf(\u0026#34;b\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;c\\n\u0026#34;; } 输出 （环境 g++5.4.0） b c a 默认的情况下cin绑定的是cout，每次执行 \u0026laquo; 操作符的时候都要调用flush，这样会增加IO负担。\nstd::ios::sync_with_stdio(false); std::cin.tie(0); 参考一 ： http://zh.cppreference.com/w/cpp/io/ios_base/sync_with_stdio\n参考二 ：http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html\n","permalink":"https://razielez.github.io/posts/c-std-ios-base-sync-with-stdio-%E5%8A%A0%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","summary":"static bool sync_with_stdio( bool sync = true );  设置标准 C++ 流是否与标准 C 流在每次输入/输出操作后同步。\n遇到cin TLE时可以用于取消cin同步, 取消之后不能和 scanf，sscanf, getchar, fgets 之类同用。\n测试 #include \u0026lt;iostream\u0026gt;#include \u0026lt;cstdio\u0026gt; int main() { std::ios::sync_with_stdio(false); std::cout \u0026lt;\u0026lt; \u0026#34;a\\n\u0026#34;; std::printf(\u0026#34;b\\n\u0026#34;); std::cout \u0026lt;\u0026lt; \u0026#34;c\\n\u0026#34;; } 输出 （环境 g++5.4.0） b c a 默认的情况下cin绑定的是cout，每次执行 \u0026laquo; 操作符的时候都要调用flush，这样会增加IO负担。\nstd::ios::sync_with_stdio(false); std::cin.tie(0); 参考一 ： http://zh.cppreference.com/w/cpp/io/ios_base/sync_with_stdio\n参考二 ：http://www.hankcs.com/program/cpp/cin-tie-with-sync_with_stdio-acceleration-input-and-output.html","title":"c++ std::ios_base::sync_with_stdio 加速输入输出"},{"content":"win10玄学bug之一\n解决方案 ：\n命令行输入\n$ netsh wlan set hostednetwork mode=allow ssid=NAME key=PASSWORD $ netsh wlan start hostednetwork 然后在网络适配器的本地连接-\u0026gt;属性-\u0026gt;共享-\u0026gt;设置共享刚才设置的WIFI热点\n","permalink":"https://razielez.github.io/posts/window-wifi-%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98/","summary":"win10玄学bug之一\n解决方案 ：\n命令行输入\n$ netsh wlan set hostednetwork mode=allow ssid=NAME key=PASSWORD $ netsh wlan start hostednetwork 然后在网络适配器的本地连接-\u0026gt;属性-\u0026gt;共享-\u0026gt;设置共享刚才设置的WIFI热点","title":"Windows10 WIFI 热点问题"},{"content":"字符串分为unicode 和 str 两种类型\n文本字符和二进制数据分别用 str 和 byte表示\n#系统默认编码设置为utf-8 \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.getdefultencoding \u0026#39;utf-8\u0026#39; \u0026gt;\u0026gt;\u0026gt; str 与 bytes 之间的转换可以用 encode 和从decode\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;Python测试\u0026#34; \u0026gt;\u0026gt;\u0026gt; s = s.encode() \u0026gt;\u0026gt;\u0026gt; print(s) b\u0026#39;Python\\xe6\\xb5\\x8b\\xe8\\xaf\\x95\u0026#39; \u0026gt;\u0026gt;\u0026gt; s = s.decode() \u0026gt;\u0026gt;\u0026gt; print(s) \u0026#39;Python测试\u0026#39; base64 \u0026gt;\u0026gt;\u0026gt; import base64 \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;asdasd\u0026#34; \u0026gt;\u0026gt;\u0026gt; s = base64.b64encode(s) \u0026gt;\u0026gt;\u0026gt; print(s) \u0026gt;\u0026gt;\u0026gt; s = base64.b64decode(s) \u0026gt;\u0026gt;\u0026gt; print(s)  参考 ： https://foofish.net/how-python3-handle-charset-encoding.html\n","permalink":"https://razielez.github.io/posts/python%E8%A7%A3%E5%86%B3%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/","summary":"字符串分为unicode 和 str 两种类型\n文本字符和二进制数据分别用 str 和 byte表示\n#系统默认编码设置为utf-8 \u0026gt;\u0026gt;\u0026gt; import sys \u0026gt;\u0026gt;\u0026gt; sys.getdefultencoding \u0026#39;utf-8\u0026#39; \u0026gt;\u0026gt;\u0026gt; str 与 bytes 之间的转换可以用 encode 和从decode\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#34;Python测试\u0026#34; \u0026gt;\u0026gt;\u0026gt; s = s.encode() \u0026gt;\u0026gt;\u0026gt; print(s) b\u0026#39;Python\\xe6\\xb5\\x8b\\xe8\\xaf\\x95\u0026#39; \u0026gt;\u0026gt;\u0026gt; s = s.decode() \u0026gt;\u0026gt;\u0026gt; print(s) \u0026#39;Python测试\u0026#39; base64 \u0026gt;\u0026gt;\u0026gt; import base64 \u0026gt;\u0026gt;\u0026gt; s = \u0026#34;asdasd\u0026#34; \u0026gt;\u0026gt;\u0026gt; s = base64.b64encode(s) \u0026gt;\u0026gt;\u0026gt; print(s) \u0026gt;\u0026gt;\u0026gt; s = base64.b64decode(s) \u0026gt;\u0026gt;\u0026gt; print(s)  参考 ： https://foofish.net/how-python3-handle-charset-encoding.html","title":"Python解决字符编码问题"},{"content":"入门 迷宫问题（最短路径） INPUT: 5 5\rSXXXX\r...XX\r.X...\r..XXX\r....G\r6 6\r......\r.S..X.\rXXX...\r....X.\r.X..XX\r.GX...\rOUPUT: 8\r10\r代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int INF = 100000007; const int mx = 1007; typedef pair\u0026lt;int, int\u0026gt; P; char maze[mx][mx];//地图 int n, m; int sx, sy;//开始坐标 int gx, gy;//结束坐标  int d[mx][mx];//到各个位置的最短距离数组  int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};//移动向量 //（sx,sy)----\u0026gt;(gx,gy)最短路径 //无法到达就是 INF int bfs(){ queue\u0026lt;P\u0026gt; que; //初始化所有位置为INF \tfor(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ d[i][j]=INF; } } //放入起点 \tque.push(P(sx,sy)); d[sx][sy]=0; //队列不为空一直执行 \twhile(que.size()){ //取出队列前端元素 \tP p=que.front(); que.pop(); //取出为终点结束搜索 \tif(p.first==gx\u0026amp;\u0026amp;p.second==gy) break; //4个方向的移动 \tfor(int i=0;i\u0026lt;4;i++){ //移动之后的位置 \tint nx=p.first+dx[i], ny=p.second+dy[i]; //判断是否访问过 \tif(0\u0026lt;=nx\u0026amp;\u0026amp;nx\u0026lt;n\u0026amp;\u0026amp;0\u0026lt;=ny\u0026amp;\u0026amp;ny\u0026lt;m\u0026amp;\u0026amp;d[nx][ny]==INF\u0026amp;\u0026amp;maze[nx][ny]!=\u0026#39;X\u0026#39;){ que.push(P(nx,ny));//放入队列， 并到该位置的距离+1 \td[nx][ny]=d[p.first][p.second]+1; } } } return d[gx][gy]; } void solve(){ int ans=bfs(); cout \u0026lt;\u0026lt; ans; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%s\u0026#34;,maze[i]); for(int j=0;j\u0026lt;m;j++){ if(maze[i][j]==\u0026#39;S\u0026#39;){ sx=i;sy=j; } if(maze[i][j]==\u0026#39;G\u0026#39;){ gx=i;gy=j; } } } solve(); return 0; } ","permalink":"https://razielez.github.io/posts/bfs/","summary":"入门 迷宫问题（最短路径） INPUT: 5 5\rSXXXX\r...XX\r.X...\r..XXX\r....G\r6 6\r......\r.S..X.\rXXX...\r....X.\r.X..XX\r.GX...\rOUPUT: 8\r10\r代码 #include \u0026lt;iostream\u0026gt;#include \u0026lt;queue\u0026gt;using namespace std; const int INF = 100000007; const int mx = 1007; typedef pair\u0026lt;int, int\u0026gt; P; char maze[mx][mx];//地图 int n, m; int sx, sy;//开始坐标 int gx, gy;//结束坐标  int d[mx][mx];//到各个位置的最短距离数组  int dx[4] = {1,0,-1,0}, dy[4] = {0,1,0,-1};//移动向量 //（sx,sy)----\u0026gt;(gx,gy)最短路径 //无法到达就是 INF int bfs(){ queue\u0026lt;P\u0026gt; que; //初始化所有位置为INF \tfor(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ d[i][j]=INF; } } //放入起点 \tque.","title":"BFS"},{"content":"题目 : L2-010. 排座位 布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。\n输入格式： 输入第一行给出3个正整数：N（\u0026lt;= 100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：“宾客1 宾客2 关系”，其中“关系”为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。\n这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。\n输出格式： 对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出“No problem”；如果他们之间并不是朋友，但也不敌对，则输出“OK”；如果他们之间有敌对，然而也有共同的朋友，则输出“OK but\u0026hellip;”；如果他们之间只有敌对关系，则输出“No way”。\n输入样例： 7 8 4\r5 6 1\r2 7 -1\r1 3 1\r3 4 1\r6 7 -1\r1 2 1\r1 4 1\r2 3 -1\r3 4\r5 7\r2 3\r7 2\r输出样例： No problem\rOK\rOK but...\rNo way\r/* 11 8 6 1 2 1 3 2 4 5 6 5 7 6 8 7 9 10 11 4 6 3 9 5 9 11 6 7 8 3 4 */ #include \u0026lt;iostream\u0026gt;using namespace std; int pre[100007];//节点 int enemy[1007][1007]; int find(int x) {//查找源头标号 \tint r = x; while (pre[r] != r) r = pre[r]; int i = x, j; while (i != r)//路径压缩算法  { j = pre[i];//在改变他的前导点时，存储他的值  pre[i] = r; i = j;//改变他的前导点为根节点  /* 1---\u0026gt;2---\u0026gt;3 1---\u0026gt;3 / / / 2 */ } return r; } void Union(int a, int b) {//合并 \ta=find(a); b=find(b); if(a==b) return; if (a!=b) pre[a]=b; } int main() { int n,m,p; cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m\u0026gt;\u0026gt;p; //初始每个元素为一个根节点 \tfor(int i=1;i\u0026lt;=n;i++){ pre[i]=i; } int a,b,c; for(int i=0;i\u0026lt;m;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b\u0026gt;\u0026gt;c; if(c==1){ Union(a,b); }else{ enemy[a][b]=1; enemy[b][a]=1; } } for(int i=0;i\u0026lt;p;i++){ cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; if(find(a)==find(b)\u0026amp;\u0026amp;enemy[a][b]==0){ cout\u0026lt;\u0026lt;\u0026#34;No problem\u0026#34;\u0026lt;\u0026lt;endl; }else if(find(a)!=find(b)\u0026amp;\u0026amp;enemy[a][b]==0){ cout\u0026lt;\u0026lt;\u0026#34;OK\u0026#34;\u0026lt;\u0026lt;endl; }else if(find(a)==find(b)\u0026amp;\u0026amp;enemy[a][b]==1){ cout\u0026lt;\u0026lt;\u0026#34;OK but...\u0026#34;\u0026lt;\u0026lt;endl; }else if(enemy[a][b]==1){ cout\u0026lt;\u0026lt;\u0026#34;No way\u0026#34;\u0026lt;\u0026lt;endl; } } return 0; } ","permalink":"https://razielez.github.io/posts/%E5%B9%B6%E6%9F%A5%E9%9B%86/","summary":"题目 : L2-010. 排座位 布置宴席最微妙的事情，就是给前来参宴的各位宾客安排座位。无论如何，总不能把两个死对头排到同一张宴会桌旁！这个艰巨任务现在就交给你，对任何一对客人，请编写程序告诉主人他们是否能被安排同席。\n输入格式： 输入第一行给出3个正整数：N（\u0026lt;= 100），即前来参宴的宾客总人数，则这些人从1到N编号；M为已知两两宾客之间的关系数；K为查询的条数。随后M行，每行给出一对宾客之间的关系，格式为：“宾客1 宾客2 关系”，其中“关系”为1表示是朋友，-1表示是死对头。注意两个人不可能既是朋友又是敌人。最后K行，每行给出一对需要查询的宾客编号。\n这里假设朋友的朋友也是朋友。但敌人的敌人并不一定就是朋友，朋友的敌人也不一定是敌人。只有单纯直接的敌对关系才是绝对不能同席的。\n输出格式： 对每个查询输出一行结果：如果两位宾客之间是朋友，且没有敌对关系，则输出“No problem”；如果他们之间并不是朋友，但也不敌对，则输出“OK”；如果他们之间有敌对，然而也有共同的朋友，则输出“OK but\u0026hellip;”；如果他们之间只有敌对关系，则输出“No way”。\n输入样例： 7 8 4\r5 6 1\r2 7 -1\r1 3 1\r3 4 1\r6 7 -1\r1 2 1\r1 4 1\r2 3 -1\r3 4\r5 7\r2 3\r7 2\r输出样例： No problem\rOK\rOK but...\rNo way\r/* 11 8 6 1 2 1 3 2 4 5 6 5 7 6 8 7 9 10 11 4 6 3 9 5 9 11 6 7 8 3 4 */ #include \u0026lt;iostream\u0026gt;using namespace std; int pre[100007];//节点 int enemy[1007][1007]; int find(int x) {//查找源头标号 \tint r = x; while (pre[r] !","title":"并查集"},{"content":"入门 求连通块 INPUT : 1 1\r*\r3 5\r*@*@*\r**@**\r*@*@*\r1 8\r@@****@*\r5 5 ****@\r*@@*@\r*@**@\r@@@*@\r@@**@\r0 0\rOUTPUT : 0\r1\r2\r2\r代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int mx = 10007; int n, m; char field[mx][mx];//地图 void dfs(int x, int y){ field[x][y] = \u0026#39;*\u0026#39;;//替换现在位置 \t//遍历8个方向 \tfor(int dx=-1;dx\u0026lt;=1;dx++){ for(int dy=-1;dy\u0026lt;=1;dy++){ int nx=x+dx, ny=y+dy; if(0\u0026lt;=nx\u0026amp;\u0026amp;nx\u0026lt;n\u0026amp;\u0026amp;0\u0026lt;=ny\u0026amp;\u0026amp;ny\u0026lt;m\u0026amp;\u0026amp;field[nx][ny]==\u0026#39;@\u0026#39;) dfs(nx,ny); } } return ; } void solve(){ int ans=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ //从@处开始遍历 \tif(field[i][j]==\u0026#39;@\u0026#39;){ dfs(i,j); ans++; }\t} } cout\u0026lt;\u0026lt;ans; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%s\u0026#34;,field[i]); }\tsolve(); return 0; } ","permalink":"https://razielez.github.io/posts/dfs/","summary":"入门 求连通块 INPUT : 1 1\r*\r3 5\r*@*@*\r**@**\r*@*@*\r1 8\r@@****@*\r5 5 ****@\r*@@*@\r*@**@\r@@@*@\r@@**@\r0 0\rOUTPUT : 0\r1\r2\r2\r代码 #include \u0026lt;iostream\u0026gt;using namespace std; const int mx = 10007; int n, m; char field[mx][mx];//地图 void dfs(int x, int y){ field[x][y] = \u0026#39;*\u0026#39;;//替换现在位置 \t//遍历8个方向 \tfor(int dx=-1;dx\u0026lt;=1;dx++){ for(int dy=-1;dy\u0026lt;=1;dy++){ int nx=x+dx, ny=y+dy; if(0\u0026lt;=nx\u0026amp;\u0026amp;nx\u0026lt;n\u0026amp;\u0026amp;0\u0026lt;=ny\u0026amp;\u0026amp;ny\u0026lt;m\u0026amp;\u0026amp;field[nx][ny]==\u0026#39;@\u0026#39;) dfs(nx,ny); } } return ; } void solve(){ int ans=0; for(int i=0;i\u0026lt;n;i++){ for(int j=0;j\u0026lt;m;j++){ //从@处开始遍历 \tif(field[i][j]==\u0026#39;@\u0026#39;){ dfs(i,j); ans++; }\t} } cout\u0026lt;\u0026lt;ans; } int main() { cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=0;i\u0026lt;n;i++){ scanf(\u0026#34;%s\u0026#34;,field[i]); }\tsolve(); return 0; } ","title":"DFS"},{"content":"数论被“数学王子”高斯誉为整个数学王国的皇后\n欧几里得算法 最大公约数 欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g\n代码示例 //递归\rint gcd(int a, int b) {\rreturn b == 0 ? a : gcd(b, a % b);\r}\r//迭代\rint gcd(int a, int b) {\rwhile(b != 0) {\rint r = b;\rb = a % b;\ra = r;\r}\rreturn a;\r}\r唯一分解定理 扩展欧几里得算法 题目\n直线上的点。求直线ax+by+c=0上有多少整数点(x,y)满足x\u0026lt;-[x1, x2], y \u0026lt;- [y1, y2] 定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)=ax+by\n代码示例 void gcd(int a, int b, int\u0026amp; d, int\u0026amp; x, int\u0026amp; y) { if (!b) { d = a; x = 1; y = 0; } else { gcd(b, a % b, d, y, x); y -= x * (a / b); } } 素数筛选 题目\n代码示例 //一般判定是否是素数 bool is_prime(int n) { if (n \u0026lt; 2) return false; for (int i = 2; i \u0026lt;= sqrt(n); i++) { if (n % i == 0) return false; } return true; } //普通筛选n内的素数 bool* com_prime(int n) { bool* ans = new bool[n]; for (int i = 0; i \u0026lt; n; i++) ans[i] = false; for (int i = 2; i \u0026lt; n; i++) { if (is_prime(i)) ans[i] = true; } return ans; } 筛选法示例 一、初始化如下列表。\n2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n二、把第一个数（2）取出来，去掉所有可以被2整除的数。\n2 3 5 7 9 11 13 15 17 19 21 23 25 27 29\n三、取第二个数（3），去掉所有可以被 3整除的数。\n2 3 5 7 11 13 17 19 23 25 29\n四、取第三个数（5），因为4已经被去除了，再去掉所有可以被5整除的数。\n2 3 5 7 11 13 17 19 23 29\n接下来的数是7，但是7的平方是49，其大于了30，所以我们可以停止计算了。剩下的数就是所有的质数了。\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;cmath\u0026gt;#define MAX 1000 using namespace std; bool is_prime(int n) { if (n \u0026lt; 2) return false; for (int i = 2; i * i \u0026lt;= n; i++) { if (n % i == 0) return false; } return true; } bool* sieve_prime(int n) { bool* value = new bool[n]; for (int i = 0; i \u0026lt; n; i++) value[i] = true; value[0] = false; value[1] = false; for (int i = 2; i \u0026lt;= sqrt(n); i++) { if (value[i] \u0026amp;\u0026amp; is_prime(i)) { int c = 2; int j = i * c; while (j \u0026lt; n) { value[j] = false; j = i * c++; } } } return value; } int main() { bool* prime = sieve_prime(MAX); for (int i = 1; i \u0026lt;=100; i++) { //输出100内的素数  if (prime[i]) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } } 欧拉函数 欧拉函数： 在数论中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n互质的数的数目。它又称为Euler\u0026rsquo;s totient function、φ函数、欧拉商数等。 例如 φ，因为1,3,5,7均和8互质。\u0026mdash;\u0026mdash; 维基百科\n定理  phi(1) = 1 n为质数, phi(n) = n - 1 m 和 n 互质, phi(mn) = phi(m) * phi(n) n为奇数, phi(2n) = phi(n) 通用公式：phi(n) = n * (1 - 1 / p1) * (1 - 1 / p2) * ... * (1 - 1 / pr) 其中 n = p1^k1 * p2^k2 * ... * pr^kr 具体参考： 看云-欧拉函数  常规代码 int phi(int n) {\rint t = n;\rfor (int i = 2; i \u0026lt;= n; i++) {\rif (n % i == 0) {\rn /= i;\rt = t - t / i;\r}\rwhile (n % i == 0)\rn /= i;\r}\rreturn t;\r}\r时间复杂度O(n),对于1e9会超时。\n改良之后 int phi(int n) {\rint t = n;\r//降低时间复杂度\rfor (int i = 2; i * i \u0026lt;= n; i++) {\rif (n % i == 0) {\rn /= i;\rt = t - t / i;\r}\rwhile (n % i == 0) n /= i;\r}\rif (n \u0026gt; 1)\rt = t - t / n;\rreturn t;\r}\r","permalink":"https://razielez.github.io/posts/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/","summary":"数论被“数学王子”高斯誉为整个数学王国的皇后\n欧几里得算法 最大公约数 欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g\n代码示例 //递归\rint gcd(int a, int b) {\rreturn b == 0 ? a : gcd(b, a % b);\r}\r//迭代\rint gcd(int a, int b) {\rwhile(b != 0) {\rint r = b;\rb = a % b;\ra = r;\r}\rreturn a;\r}\r唯一分解定理 扩展欧几里得算法 题目\n直线上的点。求直线ax+by+c=0上有多少整数点(x,y)满足x\u0026lt;-[x1, x2], y \u0026lt;- [y1, y2] 定理：若a和b为正整数，则存在整数x,y使得gcd(a,b)=ax+by\n代码示例 void gcd(int a, int b, int\u0026amp; d, int\u0026amp; x, int\u0026amp; y) { if (!","title":"数论初步"},{"content":"push代码时遇到提示：Everything up-to-date,无法push代码 原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。\n解决 在stackoverflow有解决方案\n创建分支 $ git branch newbranch\r#查看分支\r$ git branch\r切换分支 $ git checkout newbranch\r改动提交到新的分支 $ git add .\r$ git commit -a\r合并到master $ git merge newbranch\r#查看冲突\r$ git diff\rpush代码 $ git push -u origin master\r删除分支 $ git branch -D newbranch\r 删除合并部分大写D改为小写d  ","permalink":"https://razielez.github.io/posts/git%E9%97%AE%E9%A2%98everything-up-to-date%E8%A7%A3%E5%86%B3/","summary":"push代码时遇到提示：Everything up-to-date,无法push代码 原因是git提交改动到缓存，要push的时候不会将本地所有的分支都push掉，所以出现这个问题。我们应该告诉git提交哪个分支。\n解决 在stackoverflow有解决方案\n创建分支 $ git branch newbranch\r#查看分支\r$ git branch\r切换分支 $ git checkout newbranch\r改动提交到新的分支 $ git add .\r$ git commit -a\r合并到master $ git merge newbranch\r#查看冲突\r$ git diff\rpush代码 $ git push -u origin master\r删除分支 $ git branch -D newbranch\r 删除合并部分大写D改为小写d  ","title":"Git问题：Everything up-to-date解决"},{"content":"快速幂 通常算法：\nint Pow(int A, int n)\r{\rif(n == 0) return 1;\rint rslt(1);\rfor(int i(0); i \u0026lt; n; ++i)\rrslt *= A;\rreturn rslt;\r}\r其复杂度是O(n)的。一般来说，这样的复杂度并不会使我们困惑，但是一般应用幂运算的地方，指数都会非常非常的大，比如1 000 000 000这个级别的，这时候我们会遇到两个问题，第一个就是我们不能再用int来存储整数，必须用高精度整数类型来进行存储，另一个就是在指数是如此变态的数量级之下，我们的计算量会骤然上升，结果也会异常惊人的大。简单来说就是二分法。 举个栗子： 一般解法： A^8 = A * A * A * A * A * A * A * A 总共需要7次乘法运算\n平均分解： A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2 这样我们就只需要4次乘法运算\n再分解： A^6 = [(A * A) * (A * A)] ^ 2 = [(A * A) ^ 2] ^ 2 这样就将乘法运算的次数减少为了3次\n这种二分解法可以将原本n次的运算减少为logn / log2，这样的效果是惊人的，在1 000 000 000这样数量级的指数运算下，该方法可以将运算次数减少到30次\n整数的快速幂：\nint qPow(int A, int n)\r{\rif(n == 0) return 1;\rint rslt(1);\rwhile(n)\r{\rif(n \u0026amp; 1) // 若幂为奇数\r{\rrslt *= A;\r}\rA *= A;\rn \u0026gt;\u0026gt;= 1; // 右位移等价于除以2\r}\rreturn rslt;\r}\r矩阵类的代码：\nclass Matrix\r{\rpublic:\rint N; // 矩阵维数\rint** m; // 存储矩阵的二维数组\rMatrix(int n = 2)\r{\rm = new int*[n];\rfor(int i(0); i \u0026lt; n; ++i)\r{\rm[i] = new int[n];\r}\rN = n;\rclear();\r}\r// 将矩阵清空为零矩阵\rvoid clear()\r{\rfor(int i(0); i \u0026lt; N; ++i)\r{\rmemset(m[i], 0, sizeof(int) * N);\r}\r}\r// 将矩阵设定为单位矩阵\rvoid unit()\r{\rclear();\rfor(int i(0); i \u0026lt; N; ++i)\r{\rm[i][i] = 1;\r}\r}\r// 矩阵的赋值\rMatrix operator= (Matrix \u0026amp;othr)\r{\rMatrix(othr.N);\rfor(int i(0); i \u0026lt; othr.N; ++i)\r{\rfor(int j(0); j \u0026lt; othr.N; ++j)\r{\rm[i][j] = othr.m[i][j];\r}\r}\rreturn *this;\r}\r// 矩阵的乘法\r//!假设所有因子均为同阶方阵\rMatrix operator* (Matrix \u0026amp;othr)\r{\rMatrix rslt(othr.N);\rfor(int i(0); i \u0026lt; othr.N; ++i)\r{\rfor(int j(0); j \u0026lt; othr.N; ++j)\r{\rfor(int k(0); k \u0026lt; othr.N; ++k)\r{\rrslt.m[i][j] += m[i][k] * othr.m[k][j];\r}\r}\r}\rreturn rslt;\r}\r};\r矩阵快速幂的算法:\nMatrix qMPow(Matrix \u0026amp;A, int n)\r{\rMatrix rslt(A.N);\rrslt.unit();\rif(n == 0) return rslt;\rwhile(n)\r{\rif(n \u0026amp; 1) // 若幂为奇数\r{\rrslt = rslt * A;\r}\rA = A * A;\rn \u0026gt;\u0026gt;= 1; // 右位移等价于除以2\r}\rreturn rslt;\r}\r","permalink":"https://razielez.github.io/posts/%E5%BF%AB%E9%80%9F%E5%B9%82/","summary":"快速幂 通常算法：\nint Pow(int A, int n)\r{\rif(n == 0) return 1;\rint rslt(1);\rfor(int i(0); i \u0026lt; n; ++i)\rrslt *= A;\rreturn rslt;\r}\r其复杂度是O(n)的。一般来说，这样的复杂度并不会使我们困惑，但是一般应用幂运算的地方，指数都会非常非常的大，比如1 000 000 000这个级别的，这时候我们会遇到两个问题，第一个就是我们不能再用int来存储整数，必须用高精度整数类型来进行存储，另一个就是在指数是如此变态的数量级之下，我们的计算量会骤然上升，结果也会异常惊人的大。简单来说就是二分法。 举个栗子： 一般解法： A^8 = A * A * A * A * A * A * A * A 总共需要7次乘法运算\n平均分解： A^8 = (A * A * A * A) * (A * A * A * A) = (A * A * A * A) ^ 2 这样我们就只需要4次乘法运算","title":"快速幂"},{"content":"管理conda 验证安装 $ conda --version\r命令参阅可以用: conda \u0026ndash;help\n将conda更新到最新 $ conda update conda\r#有最新选择yes\rProceed ([y]/n)? y\r管理环境 创建环境 $ conda create --name snowflakes biopython\r#也可以指定python版本并安装Astroid和Babel\r$ conda create --name snowflakes python3.5 astroid babel\r使用biopython创建一个snowflakes的环境\n 不指定目录即为默认目录/envs  使用环境 $ activate newen\r#切换回根目录\r$ deactivate\r显示安装过的环境 $ conda info --envs\r括号显示为当前环境 切换到另一个环境 $ activate another_environment\r克隆删除环境 #克隆\r$ conda create --name flowers --clone snowflakes\r#删除\r$ conda remove --name flowers --all\r管理Python 检查可安装的python版本 $ conda search --full-name python\r#列出包含python的所有包\r$ conda search python\r安装python3环境并不覆盖python2 $ conda create --name snackes pyhton=3\r包管理 看安装的包和版本列表 $ conda list\r查找、安装、删除 $ conda search beautifulsoup4\r$ conda install --name snowflakes beautifulsoup4 #未指定位置安装在当前位置\r$ conda remove --name snowflakes beautifulsoup4\r从Anaconda.org安装包 $ conda install --channel https://conda.anaconda.org/pandas bottleneck\r 更多命令具体参考：Getting started  ","permalink":"https://razielez.github.io/posts/conda%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","summary":"管理conda 验证安装 $ conda --version\r命令参阅可以用: conda \u0026ndash;help\n将conda更新到最新 $ conda update conda\r#有最新选择yes\rProceed ([y]/n)? y\r管理环境 创建环境 $ conda create --name snowflakes biopython\r#也可以指定python版本并安装Astroid和Babel\r$ conda create --name snowflakes python3.5 astroid babel\r使用biopython创建一个snowflakes的环境\n 不指定目录即为默认目录/envs  使用环境 $ activate newen\r#切换回根目录\r$ deactivate\r显示安装过的环境 $ conda info --envs\r括号显示为当前环境 切换到另一个环境 $ activate another_environment\r克隆删除环境 #克隆\r$ conda create --name flowers --clone snowflakes\r#删除\r$ conda remove --name flowers --all\r管理Python 检查可安装的python版本 $ conda search --full-name python\r#列出包含python的所有包\r$ conda search python\r安装python3环境并不覆盖python2 $ conda create --name snackes pyhton=3\r包管理 看安装的包和版本列表 $ conda list\r查找、安装、删除 $ conda search beautifulsoup4\r$ conda install --name snowflakes beautifulsoup4 #未指定位置安装在当前位置\r$ conda remove --name snowflakes beautifulsoup4\r从Anaconda.","title":"conda常用操作(windows)"},{"content":"Git使用规范流程 Git是一个源码管理系统 我采取ThoughtBot的Git使用规范流程\n第一步：新建分支 每次开发新功能，都应该新建一个单独的分支。\n#获取主干最新代码\r$ git checkout master\r$ git pull\r#新建开发分支\r$ git checkout -b afeature\r第二步：提交分支commit 分支修改后，提交commit\n#all为保存所有变化(包括新建、修改和删除)\r$ git add --all\r#查看发生变动的文件。\r$ git status\r#verbose会列出diff的结果\r$ git commit --verbose\r diff是Unix系统的一个很重要的工具程序，具体见：读懂diff - 阮一峰的网络日志  第三步：撰写提交信息 提交commit时，必须给出完整扼要的提交信息。以下是一个范本：\nPersent-tense summary under 50 characters\r*More information about commit(under 72 characters)\r*More information about commit(under 72 characters)\rhttp://project.management-system.com/ticket/123\r第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、需要注意的问题。最后，提供对应的网址。\n第四步：与主干同步 $ git fetch orgin\r$ git rebase orgin/master\r第五步：合并commit 分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个(或最多两三个) commit，这样不仅清晰，也容易管理。\n$ git rebase -i origin/master\r 具体参考：Git 使用规范流程  第六步：推送到远程仓库 合并commit，推送当前分支到远程仓库。\n$ git push --force origin myfeature\r第七步：发出Pull Request 提交到远程仓库以后，就可以发出Pull Request 到master 分支，然后请求别人进行代码review，确认可以合并到master。\nGit常用操作 ","permalink":"https://razielez.github.io/posts/%E5%88%9D%E5%AD%A6%E4%BD%BF%E7%94%A8git/","summary":"Git使用规范流程 Git是一个源码管理系统 我采取ThoughtBot的Git使用规范流程\n第一步：新建分支 每次开发新功能，都应该新建一个单独的分支。\n#获取主干最新代码\r$ git checkout master\r$ git pull\r#新建开发分支\r$ git checkout -b afeature\r第二步：提交分支commit 分支修改后，提交commit\n#all为保存所有变化(包括新建、修改和删除)\r$ git add --all\r#查看发生变动的文件。\r$ git status\r#verbose会列出diff的结果\r$ git commit --verbose\r diff是Unix系统的一个很重要的工具程序，具体见：读懂diff - 阮一峰的网络日志  第三步：撰写提交信息 提交commit时，必须给出完整扼要的提交信息。以下是一个范本：\nPersent-tense summary under 50 characters\r*More information about commit(under 72 characters)\r*More information about commit(under 72 characters)\rhttp://project.management-system.com/ticket/123\r第一行是不超过50个字的提要，然后空一行，罗列出改动原因、主要变动、需要注意的问题。最后，提供对应的网址。\n第四步：与主干同步 $ git fetch orgin\r$ git rebase orgin/master\r第五步：合并commit 分支开发完成后，很可能有一堆commit，但是合并到主干的时候，往往希望只有一个(或最多两三个) commit，这样不仅清晰，也容易管理。","title":"初学使用Git"},{"content":" 机场最为方便 v2ray适合自建 \u0026hellip;  ","permalink":"https://razielez.github.io/posts/%E9%80%9A%E5%90%91%E5%A4%96%E7%BD%91%E7%9A%84%E6%A2%AF%E5%AD%90/","summary":" 机场最为方便 v2ray适合自建 \u0026hellip;  ","title":"通向外网的梯子"},{"content":"Jupyter Notebook 有两种键盘输入模式，命令模式和编辑模式。与Vim类似。\n命令模式按Esc进入，编辑模式按Enter进入\n命令模式快捷键    快捷键 作用     Shift+Enter 运行本单元，选中下一个单元   Ctrl+Enter 运行本单元   Alt+Enter 运行本单元在下插入新单元   Y 单元转入代码状态   M 单元转入markdown状态   R 单元转入raw状态   Up\u0026amp;K/Down\u0026amp;J 选中上方/下方单元   Shift+K/J 连续选择上方/下方单元   A/B 在上方/下方插入新单元   x/C 剪切/复制选中单元   Shift+V/V 粘贴到上方/下方单元   Z 恢复删除的最后一个单元   DD 删除选中的单元   Shift+M 合并选中的单元   Ctrl+S/S 保存当前文件   L 开关行号   O 转换输出   Shift+O 转换输出滚动   Esc/Q 关闭页面   H 显示快捷帮助   II/00 中断/重启NOteBook内核   Shift+Space/Space 向上/下滚动    编辑模式快捷键    快捷键 作用     Tab 代码补全或者缩进   Shift+Tab 提示   Ctrl+] 向右缩进   Ctrl+[ 向左缩进   Ctrl+Shift+Z/Ctrl+Y 重做   Ctrl+up/down 跳到单元开头/末尾   Ctrl+Left/Right 跳到左边/右边一个字首   Ctrl+BackSpace/Delete 删除前面一个字   Shift+Enter 运行本单元，选中下一个单元   Ctrl+M 切换到命令模式   Ctrl+Enter 运行本单元   Alt+Enter 运行本单元在下插入新单元   Ctrl+/ 注释整行或者取消注释    ","permalink":"https://razielez.github.io/posts/jupyter-notebook%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","summary":"Jupyter Notebook 有两种键盘输入模式，命令模式和编辑模式。与Vim类似。\n命令模式按Esc进入，编辑模式按Enter进入\n命令模式快捷键    快捷键 作用     Shift+Enter 运行本单元，选中下一个单元   Ctrl+Enter 运行本单元   Alt+Enter 运行本单元在下插入新单元   Y 单元转入代码状态   M 单元转入markdown状态   R 单元转入raw状态   Up\u0026amp;K/Down\u0026amp;J 选中上方/下方单元   Shift+K/J 连续选择上方/下方单元   A/B 在上方/下方插入新单元   x/C 剪切/复制选中单元   Shift+V/V 粘贴到上方/下方单元   Z 恢复删除的最后一个单元   DD 删除选中的单元   Shift+M 合并选中的单元   Ctrl+S/S 保存当前文件   L 开关行号   O 转换输出   Shift+O 转换输出滚动   Esc/Q 关闭页面   H 显示快捷帮助   II/00 中断/重启NOteBook内核   Shift+Space/Space 向上/下滚动    编辑模式快捷键    快捷键 作用     Tab 代码补全或者缩进   Shift+Tab 提示   Ctrl+] 向右缩进   Ctrl+[ 向左缩进   Ctrl+Shift+Z/Ctrl+Y 重做   Ctrl+up/down 跳到单元开头/末尾   Ctrl+Left/Right 跳到左边/右边一个字首   Ctrl+BackSpace/Delete 删除前面一个字   Shift+Enter 运行本单元，选中下一个单元   Ctrl+M 切换到命令模式   Ctrl+Enter 运行本单元   Alt+Enter 运行本单元在下插入新单元   Ctrl+/ 注释整行或者取消注释    ","title":"Jupyter NoteBook常用快捷键"},{"content":"Wox **Wox：**是开源免费强大的快捷启动器辅助工具，快速高效率打开软件,搜索文件 打开输入框：alt + space\n 同类软件也有: ** Listary** , **Rolan**  包管理工具 **Chocolatey：**如果你认为没有包管理的操作系统是反人类的就用这个吧，Chocolatey 这套包管理系统目前已经包含了近 500 多款常用软件，常用的有Sublime text,git,Google Chrome······\n命令行工具 MobaXterm, 功能强大 cmder： 不多说，windows命令行神器，支持tab补全，支持了大部分的Linux命令······\n文本编辑器 Sublime text3：基于 Python 语言的外挂 API,跨平台（Windows、Linux 和 Mac OS X）,兼容 TextMate 的语言标记语法。关于软件的配置方面见：这里 sublime text 3 3143 license\n—– BEGIN LICENSE —–\rTwitterInc\r200 User License\rEA7E-890007\r1D77F72E 390CDD93 4DCBA022 FAF60790\r61AA12C0 A37081C5 D0316412 4584D136\r94D7F7D4 95BC8C1C 527DA828 560BB037\rD1EDDD8C AE7B379F 50C9D69D B35179EF\r2FE898C4 8E4277A8 555CE714 E1FB0E43\rD5D52613 C3D12E98 BC49967F 7652EED2\r9D2D2E61 67610860 6D338B72 5CF95C69\rE36B85CC 84991F19 7575D828 470A92AB\r—— END LICENSE —— 同类也有：  **VS Code：**毕竟宇宙级的 **Atom：**Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.js所写的插件，并内置Git版本控制系统。(维基百科)，插件需要科学上网 **Notepad++：**Notepad++，由台湾人侯今吾基于同是开放源代码的Scintilla文本编辑组件并独力研发，整个项目托管于SourceForge.net之上，并两度获得SourceForge社区选择奖——最佳开发工具。（维基百科） 由于sublime现在有些功能没有， 我现在使用的是VScode  IDE 没什么说的，大多数网上都能下载，JetBrains家的东西都不错，由于对学生免费，即用教育网邮箱注册，就能获得大学在校的使用时间，分享一个用于接收EDU邮箱的网站：点击这里\n待续\u0026mdash;\u0026ndash;\n **注：**0x13哒的缘故，上面网址有的需要突破GFW的封锁，科学上网详见：这里  ","permalink":"https://razielez.github.io/posts/windows%E4%B8%8A%E5%A5%BD%E7%94%A8%E7%9A%84%E8%BD%AF%E4%BB%B6/","summary":"Wox **Wox：**是开源免费强大的快捷启动器辅助工具，快速高效率打开软件,搜索文件 打开输入框：alt + space\n 同类软件也有: ** Listary** , **Rolan**  包管理工具 **Chocolatey：**如果你认为没有包管理的操作系统是反人类的就用这个吧，Chocolatey 这套包管理系统目前已经包含了近 500 多款常用软件，常用的有Sublime text,git,Google Chrome······\n命令行工具 MobaXterm, 功能强大 cmder： 不多说，windows命令行神器，支持tab补全，支持了大部分的Linux命令······\n文本编辑器 Sublime text3：基于 Python 语言的外挂 API,跨平台（Windows、Linux 和 Mac OS X）,兼容 TextMate 的语言标记语法。关于软件的配置方面见：这里 sublime text 3 3143 license\n—– BEGIN LICENSE —–\rTwitterInc\r200 User License\rEA7E-890007\r1D77F72E 390CDD93 4DCBA022 FAF60790\r61AA12C0 A37081C5 D0316412 4584D136\r94D7F7D4 95BC8C1C 527DA828 560BB037\rD1EDDD8C AE7B379F 50C9D69D B35179EF\r2FE898C4 8E4277A8 555CE714 E1FB0E43\rD5D52613 C3D12E98 BC49967F 7652EED2\r9D2D2E61 67610860 6D338B72 5CF95C69\rE36B85CC 84991F19 7575D828 470A92AB\r—— END LICENSE —— 同类也有：  **VS Code：**毕竟宇宙级的 **Atom：**Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持OS X、Windows和Linux操作系统，支持Node.","title":"Windows上好用的软件"},{"content":"数字转字符串 #include \u0026lt;sstream\u0026gt;double a = 123.456; string s; stringstream ss; ss \u0026lt;\u0026lt; a; ss \u0026gt;\u0026gt; s; ss.clear(); #include \u0026lt;map\u0026gt;map\u0026lt;int, char\u0026gt; m; for (int i = 0; i \u0026lt; 10; i++) { m[i] = i + \u0026#39;0\u0026#39;; } #include \u0026lt;cstdio\u0026gt;char str[10]; double a = 123.456; sprintf(str, \u0026#34;%.3lf\u0026#34;, a); char str[10]; int a=175; sprintf(str,\u0026#34;%x\u0026#34;,a);//10进制转换成16进制，如果输出大写的字母是sprintf(str,\u0026#34;%X\u0026#34;,a) 字符串转数字 #include \u0026lt;sstream\u0026gt;string s = \u0026#34;123.456\u0026#34;; double a; stringstream ss; ss \u0026lt;\u0026lt; s; ss \u0026gt;\u0026gt; a; ss.clear(); #include \u0026lt;map\u0026gt;map\u0026lt;char, int\u0026gt; m; for (int i = 0; i \u0026lt; 10; i++) { m[i+\u0026#39;0\u0026#39;] = i; } #include \u0026lt;cstdio\u0026gt;char str[] = \u0026#34;123.456\u0026#34;; double a; sscanf(str, \u0026#34;%lf\u0026#34;, \u0026amp;a); char str[]=\u0026#34;AF\u0026#34;; int a; sscanf(str,\u0026#34;%x\u0026#34;,\u0026amp;a); //16进制转换成10进制 #include \u0026lt;cstdlib\u0026gt;int a;float b;long c; a=atoi(\u0026#34;32\u0026#34;); b=atof(\u0026#34;3.1415\u0026#34;); c=atol(\u0026#34;567283\u0026#34;); printf (\u0026#34;%d\\n%f\\n%d\\n\u0026#34;,a,b,c); ","permalink":"https://razielez.github.io/posts/c++%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E8%BD%AC%E6%8D%A2/","summary":"数字转字符串 #include \u0026lt;sstream\u0026gt;double a = 123.456; string s; stringstream ss; ss \u0026lt;\u0026lt; a; ss \u0026gt;\u0026gt; s; ss.clear(); #include \u0026lt;map\u0026gt;map\u0026lt;int, char\u0026gt; m; for (int i = 0; i \u0026lt; 10; i++) { m[i] = i + \u0026#39;0\u0026#39;; } #include \u0026lt;cstdio\u0026gt;char str[10]; double a = 123.456; sprintf(str, \u0026#34;%.3lf\u0026#34;, a); char str[10]; int a=175; sprintf(str,\u0026#34;%x\u0026#34;,a);//10进制转换成16进制，如果输出大写的字母是sprintf(str,\u0026#34;%X\u0026#34;,a) 字符串转数字 #include \u0026lt;sstream\u0026gt;string s = \u0026#34;123.456\u0026#34;; double a; stringstream ss; ss \u0026lt;\u0026lt; s; ss \u0026gt;\u0026gt; a; ss.clear(); #include \u0026lt;map\u0026gt;map\u0026lt;char, int\u0026gt; m; for (int i = 0; i \u0026lt; 10; i++) { m[i+\u0026#39;0\u0026#39;] = i; } #include \u0026lt;cstdio\u0026gt;char str[] = \u0026#34;123.","title":"c++的字符串与数字的转换"},{"content":"错误 （django.db.utils.OperationalError: (1045, \u0026quot;Access denied for user 'root'@'localhost' (using password: NO)\u0026quot;)）\r环境：  Django2.0 MySQL8.0.11  Mysql 8.0 的部分语法，密码的加密方式发生了改变，在8.0 中的用户密码采用的是cha2 加密方法, 从而密码认证错误。\n解决: $ mysql -u root -p mysql\u0026gt; use mysql; mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; ","permalink":"https://razielez.github.io/posts/django%E9%93%BE%E6%8E%A5mysql%E9%97%AE%E9%A2%98/","summary":"错误 （django.db.utils.OperationalError: (1045, \u0026quot;Access denied for user 'root'@'localhost' (using password: NO)\u0026quot;)）\r环境：  Django2.0 MySQL8.0.11  Mysql 8.0 的部分语法，密码的加密方式发生了改变，在8.0 中的用户密码采用的是cha2 加密方法, 从而密码认证错误。\n解决: $ mysql -u root -p mysql\u0026gt; use mysql; mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; ","title":"django链接MySQL问题"},{"content":"调用格式: scanf(\u0026quot;\u0026lt;格式化字符串\u0026gt;\u0026quot;, \u0026lt;地址表\u0026gt;); 一、为变量赋值时表示成功读取变量的个数, \u0026lt;格式化字符串\u0026gt;与\u0026lt;地址表\u0026gt;是严格匹配的\nscanf(\u0026#34;%c %c\u0026#34;, \u0026amp;a, \u0026amp;b); //函数返回值是2，并丢弃不想使用的空白符 scanf(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); //输入必须有逗号， 多个空格为一个空格 二、 %s 读取遇到空格停止读取，因此一般可以用fgets去读取字符串\nscanf(\u0026#34;%[a-z]\u0026#34;, \u0026amp;str); //遇到不再a-z字符停止读取 scanf(\u0026#34;666%[0-9]\u0026#34;, \u0026amp;str); //666开头并且在0-9字符读取，不是则停止 scanf(\u0026#34;%[^\\n]\u0026#34;, \u0026amp;str); //^表示求反集，即这句话不是回车一直开始读取 三、压缩输入：在格式码前加上*，则用户就可以告诉scanf()读这个域，但不把它赋予任何变量。\nscanf(\u0026#34;%c%*c, \u0026amp;ch); 使用此方法可以在字符处理时吃掉多余的回车。 更多正则表达式语言参考\nsscanf、scanf的一些示例 ","permalink":"https://razielez.github.io/posts/scanf%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"调用格式: scanf(\u0026quot;\u0026lt;格式化字符串\u0026gt;\u0026quot;, \u0026lt;地址表\u0026gt;); 一、为变量赋值时表示成功读取变量的个数, \u0026lt;格式化字符串\u0026gt;与\u0026lt;地址表\u0026gt;是严格匹配的\nscanf(\u0026#34;%c %c\u0026#34;, \u0026amp;a, \u0026amp;b); //函数返回值是2，并丢弃不想使用的空白符 scanf(\u0026#34;%d,%d\u0026#34;, \u0026amp;a, \u0026amp;b); //输入必须有逗号， 多个空格为一个空格 二、 %s 读取遇到空格停止读取，因此一般可以用fgets去读取字符串\nscanf(\u0026#34;%[a-z]\u0026#34;, \u0026amp;str); //遇到不再a-z字符停止读取 scanf(\u0026#34;666%[0-9]\u0026#34;, \u0026amp;str); //666开头并且在0-9字符读取，不是则停止 scanf(\u0026#34;%[^\\n]\u0026#34;, \u0026amp;str); //^表示求反集，即这句话不是回车一直开始读取 三、压缩输入：在格式码前加上*，则用户就可以告诉scanf()读这个域，但不把它赋予任何变量。\nscanf(\u0026#34;%c%*c, \u0026amp;ch); 使用此方法可以在字符处理时吃掉多余的回车。 更多正则表达式语言参考\nsscanf、scanf的一些示例 ","title":"scanf中的正则表达式"},{"content":" 事务  数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。\n 特性 事务应该具有4个属性：原子性、一致性、隔离性、持久性。\n原子性（Atomicity）：数据库事务是一个不可分割的单位。只有事务中所有的数据库操作成功，才算整个事务才算成功。只读操作，保证一致性很简单，一旦出现错误，要么重试，要么返回错误代码。\n一致性（Consistency）：事务将数据库从一种状态转变为下一种一致的状态。事务开始之前和结束之后，数据库的完整性约束没有被破坏。例如，数据操作失败，表中姓名字段在唯一的情况下，撤销之后导致重复，从而破坏了事务的一致性。\n隔离性（Isolation）：别的称呼，并发控制（concurrency control）、可串行化（serialzability）、锁（locking）等。事务隔离性要求每个读写事务对其他事务的操作对象能实现相互分离，即事务提交之前对其他事务不可见，通常使用锁实现。\n持久性（Durability）：事务一旦提交结果是永久性的，发生宕机等事故，数据库也能将数据恢复。持久性事务保证的是高可靠性，而不是高可用性，事务本身不能完成，需要系统共同配合来实现。\n分类 扁平事务、带有保存点的扁平事务、链事务、嵌套事务、分布式事务。\n隔离级别  未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞     隔离级别 脏读 丢失更新 不可重复读 幻读 并发模型 更新冲突检测     未提交读：Read Uncommited √ √ √ √ 悲观 ×   已提交读：Read commited × × √ √ 悲观 ×   可重复读：Repeatable Read × × × √ 悲观 ×   可串行读：Serializable × × × × 悲观 ×    接下来详细解释，假设有下面两个事务同时执行：\nbegin; -- 事务1 insert into table1 (somevaue); -- 随意写的伪sql update table2 set aa = aa + 1 where id = 1; commit; begin; -- 事务2 select count(*) from table1; -- 第一次读count select aa from table2 where id = 1; -- 第一次读aa -- 假设在这个点 事务1成功提交 select count(*) from table1; -- 第二次读count select aa from table2 where id = 1; -- 第二次读aa commit; 串行化不用解释了，依次执行，不会产生冲突。\n可重复读是什么意思呢？ 事务2执行到一半时，事务1 成功提交：\n事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。 事务2中 第一次读aa 和第二次读aa得到的值是一样的，对刚更新的值不可见，隔离已经存在的数据。 可以重复读，读到的数据都是一样的。\n读取已提交是什么意思呢？ 事务2执行到一半时，事务1 成功提交： 事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。 事务2中 第一次读aa 和第二次读aa得到的值是不一样的，对刚提交的值可见，不隔离已经存在的数据。 不可以重复读，读到的数据是不一样的(如果成功修改)。\n读取未提交是什么意思呢？ 事务2执行到一半时，事务1 还未提交： 事务2中 第二次读count得到的值和第一次读count得到的值不一样(因为事务1新增了一条数据)，这叫幻读，不隔离新增的数据。 事务2中 第一次读aa 和第二次读aa得到的值是不一样的（事务1未提交），对最新版本的值可见，不隔离已经存在的数据。 不可以重复读，读到的数据是不一样的。如果此时事务1因为其他原因回滚了，事务2第二次读到的数据是无意义的，因为修改没有发生(回滚了)，这叫脏读 。\n在现实环境中，串行化一般不会被使用，因为性能太低。\n如果对一致性有要求，比如转账交易，那么要使用可重复读，并发性能相对较差。 原因是，为了实现可重复读，在对更新记录加锁时，除了使用记录锁，还可能会使用间隙锁锁住区间(看update语句的where条件)，这会增加其他事务等待时间。\n如果对一致性要求不高，一般使用读取已提交, 由于不考虑重复读，在加锁时一般只加记录锁，不会使用间隙锁，并发性较好，据说使用的最多。\n持久化 事务隔离性由锁实现。原子性、一致性、持久性通过数据库的redo log（重做日志保证原子性和持久性）和undo log（保证一致性）完成。\nredo和undo都可视为恢复操作，redo恢复事务提交的页操作，undo回滚到某个特定版本。根据内容分别分为物理日志（页的物理修改操作）和逻辑日志（根据每行进行记录）\n事务日志 数据库通过事务日志来达到这个目标。 事务的每一个操作（增/删/改）产生一条日志，内容组成大概如下：\n LSN：一个按时间顺序分配的唯一日志序列号，靠后的操作的LSN比靠前的大。 TransID：产生操作的事务ID。 PageID：被修改的数据在磁盘上的位置，数据以页为单位存储。 PrevLSN：同一个事务产生的上一条日志记录的指针。 UNDO：取消本次操作的方法，按照此方法回滚。 REDO：重复本次操作的方法，如有必要，重复此方法保证操作成功。  磁盘上每个页（保存数据的，不是保存日志的）都记录着最后一个修改该数据操作的LSN。数据库会通过解析事务日志，将修改真正落到磁盘上(写盘)，随后清理事务日志(正常情况下)。\n这也是数据库在保证数据安全和性能这两个点之前的折中办法：\n 如果每次更新都写盘，由于数据是随机的，会造成大量的随机IO，性能会非常差 如果每次更新不马上写盘，那一旦数据库崩溃，数据就会丢失  折中的办法就是：\n 将数据的变更以事务日志的方式，按照时间先后追加到日志缓冲区，由特定算法写入事务日志，这是顺序IO，性能较好 通过数据管理器解析事务日志，由特定的算法择机进行写盘  数据库恢复 当数据库从崩溃中恢复时，会有以下几个步骤：\n1.解析存在的事务日志，分析哪些事务需要回滚，哪些需要写盘(还没来得及写盘，数据库就崩溃了)。\n2.Redo，进行写盘。检测对应数据所在数据页的LSN，如果数据页的LSN\u0026gt;=事务操作的LSN，说明已经写过盘，不然进行写盘操作。\n3.Undo, 按照LSN倒序进行回滚\n参考 深入理解数据库事务\n我理解的数据库事务\n","permalink":"https://razielez.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/","summary":"事务  数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。\n 特性 事务应该具有4个属性：原子性、一致性、隔离性、持久性。\n原子性（Atomicity）：数据库事务是一个不可分割的单位。只有事务中所有的数据库操作成功，才算整个事务才算成功。只读操作，保证一致性很简单，一旦出现错误，要么重试，要么返回错误代码。\n一致性（Consistency）：事务将数据库从一种状态转变为下一种一致的状态。事务开始之前和结束之后，数据库的完整性约束没有被破坏。例如，数据操作失败，表中姓名字段在唯一的情况下，撤销之后导致重复，从而破坏了事务的一致性。\n隔离性（Isolation）：别的称呼，并发控制（concurrency control）、可串行化（serialzability）、锁（locking）等。事务隔离性要求每个读写事务对其他事务的操作对象能实现相互分离，即事务提交之前对其他事务不可见，通常使用锁实现。\n持久性（Durability）：事务一旦提交结果是永久性的，发生宕机等事故，数据库也能将数据恢复。持久性事务保证的是高可靠性，而不是高可用性，事务本身不能完成，需要系统共同配合来实现。\n分类 扁平事务、带有保存点的扁平事务、链事务、嵌套事务、分布式事务。\n隔离级别  未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读) 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞     隔离级别 脏读 丢失更新 不可重复读 幻读 并发模型 更新冲突检测     未提交读：Read Uncommited √ √ √ √ 悲观 ×   已提交读：Read commited × × √ √ 悲观 ×   可重复读：Repeatable Read × × × √ 悲观 ×   可串行读：Serializable × × × × 悲观 ×    接下来详细解释，假设有下面两个事务同时执行：","title":"数据库事务"}]