<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Razielez's Blog</title><meta name=keywords content><meta name=description content="Record programming learning, bug fixes and some technical documents."><meta name=author content><link rel=canonical href=https://razielez.github.io/posts/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.fef89dbd8fd8ffe465fea8fb5995a422e1060f64e336bb02afa6c128bd5f0c32.css integrity="sha256-/vidvY/Y/+Rl/qj7WZWkIuEGD2TjNrsCr6bBKL1fDDI=" rel="preload stylesheet" as=style><link rel=icon href=https://razielez.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://razielez.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://razielez.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://razielez.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://razielez.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.82.0"><link rel=alternate type=application/rss+xml href=https://razielez.github.io/posts/index.xml><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Posts"><meta property="og:description" content="Record programming learning, bug fixes and some technical documents."><meta property="og:type" content="website"><meta property="og:url" content="https://razielez.github.io/posts/"><meta property="og:image" content="https://razielez.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Razielez's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://razielez.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Record programming learning, bug fixes and some technical documents."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://razielez.github.io/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://razielez.github.io accesskey=h title="Razielez's Blog (Alt + H)">Razielez's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://razielez.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://razielez.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://razielez.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://razielez.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://razielez.github.io>Home</a></div><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2>博客的重新整理</h2></header><section class=entry-content><p>博客的重新整理 之前用过wp、hexo体验都不是非常完美，记得毕业的时候还经常用hexo记录一些日常，使用mac后就没在重新搭建环境荒废掉了，也慢慢切向notion，现在主要还是喜欢用命令行直接写一些东西，打开一个笔记本软件也挺麻烦的，notion看起来也不是很有必要性，想一想还是需要记录一些日常开发和生活遇到的一些问题和想法，由此这便是这个博客重新整理的一些初衷。
剩下的还有一些旧的数据的迁移和废弃
废弃掉一些旧的数据 同步新的数据 数据同步最佳实践 坚持下来…</p></section><footer class=entry-footer>2021-08-23&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 博客的重新整理" href=https://razielez.github.io/posts/%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%87%8D%E6%96%B0%E6%95%B4%E7%90%86/></a></article><article class=post-entry><header class=entry-header><h2>对IDEA调优</h2></header><section class=entry-content><p>工具 jps jstat -gcutil 9448 1000 jconsole.exe IDEA调优后的参数 -server -Xms3g -Xmx3g -XX:NewRatio=5 -Xss16m -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:ConcGCThreads=4 -XX:ReservedCodeCacheSize=512m -XX:+TieredCompilation -XX:SoftRefLRUPolicyMSPerMB=50 -ea -Dsun.io.useCanonCaches=false-Djava.net.preferIPv4Stack=true-XX:+HeapDumpOnOutOfMemoryError -XX:-OmitStackTraceInFastThrow 相关参数介绍 # custom IntelliJ IDEA VM options ##################JVM模式############################ # IDEA的JVM以Server模式启动（新生代默认使用ParNew） -server ##################内存分配############################ # 堆初始值占用3G，意味着IDEA启动即分配3G内存 -Xms3g # 堆最大值占用3G -Xmx3g # 强制JVM在启动时申请到足够的堆内存（否则IDEA启动时堆初始大小不足3g） -XX:+AlwaysPreTouch # 年轻代与老年代比例为1:3（默认值是1:4），降低年轻代的回收频率 -XX:NewRatio=3 # 栈帧大小为16m -Xss16m ##################老年代回收器############################ # 使用CMS老年代回收器 -XX:+UseConcMarkSweepGC # CMS的重新标记步骤：多线程一起执行 -XX:+CMSParallelRemarkEnabled # CMS的并发标记步骤：启用4个线程并发标记（理论上越多越好，前提是CPU核心足够多） -XX:ConcGCThreads=4 ##################JIT编译器############################ # 代码缓存，用于存放Just In Time编译后的本地代码，如果塞满，JVM将只解释执行，不再编译native代码。 -XX:ReservedCodeCacheSize=512m # 分层编译，JIT编译优化越来越好，IDEA运行时间越久越快 -XX:+TieredCompilation # 节省64位指针占用的空间，代价是JVM额外开销 -XX:+UseCompressedOops # 增大软引用在JVM中的存活时长（堆空闲空间越大越久） -XX:SoftRefLRUPolicyMSPerMB=50 -Dsun....</p></section><footer class=entry-footer>2019-10-25&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 对IDEA调优" href=https://razielez.github.io/posts/%E4%B8%80%E6%AC%A1%E5%AF%B9idea%E7%9A%84%E8%B0%83%E4%BC%98/></a></article><article class=post-entry><header class=entry-header><h2>SQL练习题</h2></header><section class=entry-content><p>闲着没事情做几道SQL题。 Orcal SQL: 在线SQL测试
MySQL指定进入某个端口命令
mysql -uroot -p -P 3307 问题描述 1.学生表 Student(SID,Sname,Sage,Ssex) –SID 学生编号,Sname 学生姓名,Sage 出生年月,Ssex 学生性别. 2.课程表 Course(CID,Cname,TID) –CID –课程编号,Cname 课程名称,TID 教师编号. 3.教师表 Teacher(TID,Tname) –TID 教师编号,Tname 教师姓名. 4.成绩表 SC(SID,CID,score) –SID 学生编号,CID 课程编号,score 分数. 建表语句:
create table Student(SID varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10)); insert into Student values('01' , '赵雷' , '1990-01-01' , '男'); insert into Student values('02' , '钱电' , '1990-12-21' , '男'); insert into Student values('03' , '孙风' , '1990-05-20' , '男'); insert into Student values('04' , '李云' , '1990-08-06' , '男'); insert into Student values('05' , '周梅' , '1991-12-01' , '女'); insert into Student values('06' , '吴兰' , '1992-03-01' , '女'); insert into Student values('07' , '郑竹' , '1989-07-01' , '女'); insert into Student values('08' , '王菊' , '1990-01-20' , '女'); create table Course(CID varchar(10),Cname nvarchar(10),TID varchar(10)); insert into Course values('01' , '语文' , '02'); insert into Course values('02' , '数学' , '01'); insert into Course values('03' , '英语' , '03'); create table Teacher(TID varchar(10),Tname nvarchar(10)); insert into Teacher values('01' , '张三'); insert into Teacher values('02' , '李四'); insert into Teacher values('03' , '王五'); create table SC(SID varchar(10),CID varchar(10),score decimal(18,1)); insert into SC values('01' , '01' , 80); insert into SC values('01' , '02' , 90); insert into SC values('01' , '03' , 99); insert into SC values('02' , '01' , 70); insert into SC values('02' , '02' , 60); insert into SC values('02' , '03' , 80); insert into SC values('03' , '01' , 80); insert into SC values('03' , '02' , 80); insert into SC values('03' , '03' , 80); insert into SC values('04' , '01' , 50); insert into SC values('04' , '02' , 30); insert into SC values('04' , '03' , 20); insert into SC values('05' , '01' , 76); insert into SC values('05' , '02' , 87); insert into SC values('06' , '01' , 31); insert into SC values('06' , '03' , 34); insert into SC values('07' , '02' , 89); insert into SC values('07' , '03' , 98); 题目 查询"01"课程比"02"课程成绩高的学生的信息及课程分数 查询同时存在"01"课程和"02"课程的情况 结果: +------+-------+---------------------+------+------------+------------+ | SID | Sname | Sage | Ssex | 01课程分数 | 02课程分数 | +------+-------+---------------------+------+------------+------------+ | 02 | 钱电 | 1990-12-21 00:00:00 | 男 | 70....</p></section><footer class=entry-footer>2019-10-15&nbsp;·&nbsp;11 min</footer><a class=entry-link aria-label="post link to SQL练习题" href=https://razielez.github.io/posts/%E5%87%A0%E9%81%93sql%E7%BB%83%E4%B9%A0%E9%A2%98/></a></article><article class=post-entry><header class=entry-header><h2>Java线程检测死锁</h2></header><section class=entry-content><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
Java线程中我们构造两个相互等待对方释放资源的线程就构成了死锁。
代码：
public class DeadLockSimulation { private static String A = "a"; private static String B = "b"; public static void main(String[] args) { new DeadLockSimulation().deadLock(); } private void deadLock() { Thread t1 = new Thread(new Runnable() { @Override public void run() { synchronized (A) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (B) { System.out.println("t1"); } } } }); Thread t2 = new Thread(new Runnable() { @Override public void run() { synchronized (B) { synchronized (A) { System....</p></section><footer class=entry-footer>2019-08-10&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Java线程检测死锁" href=https://razielez.github.io/posts/java%E7%BA%BF%E7%A8%8B%E6%A3%80%E6%B5%8B%E6%AD%BB%E9%94%81/></a></article><article class=post-entry><header class=entry-header><h2>Java两个线程之间共享数据</h2></header><section class=entry-content><p>Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。
Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。
有以下常规实现方法：
一、数据抽象成一个类，对数据操作的方法封装在类里
public class MyData1 { private int j = 0; public static void main(String[] args) { MyData1 data = new MyData1(); AddRunnable addRunnable = new AddRunnable(data); DecRunnable decRunnable = new DecRunnable(data); new Thread(addRunnable).start(); new Thread(decRunnable).start(); } public synchronized void add() { j++; System.out.println("线程：" + Thread.currentThread().getName() + " j为：" + j); } public synchronized void dec() { j--; System.out.println("线程：" + Thread.currentThread().getName() + " j为：" + j); } public int getData() { return j; } } class AddRunnable implements Runnable { MyData1 data1 = new MyData1(); public AddRunnable(MyData1 data1) { this....</p></section><footer class=entry-footer>2019-07-01&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Java两个线程之间共享数据" href=https://razielez.github.io/posts/java%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/></a></article><article class=post-entry><header class=entry-header><h2>Java基础复习（一）</h2></header><section class=entry-content><p>Java基础 面向对象六原则一法则 单一职责原则（Single-Resposibility Principle） 一个类只做它该做的事情。（单一职责原则想表达的就是"高内聚"，写代码最终极的原则只有六个字"高内聚、低耦合"，所谓的高内聚就是一个代码模块只完成一项功能，在面向对象中，如果只让一个类完成它该做的事，而不涉及与它无关的领域就是践行了高内聚的原则，这个类就只有单一职责。另一个是模块化一个好的软件系统，它里面的每个功能模块也应该是可以轻易的拿到其他系统中使用的，这样才能实现软件复用的目标。）。
开放封闭原则（Open-Closed principle） 软件实体应当对扩展开放，对修改关闭。（在理想的状态下，当我们需要为一个软件系统增加新功能时，只需要从原来的系统派生出一些新类就可以，不需要修改原来的任何一行代码。要做到开闭有两个要点：1. 抽象是关键，一个系统中如果没有抽象类或接口系统就没有扩展点；2. 封装可变性，将系统中的各种可变因素封装到一个继承结构中，如果多个可变因素混杂在一起，系统将变得复杂而换乱，如果不清楚如何封装可变性）
Liskov替换原则（Liskov-Substituion Principle） 里氏替换原则，任何时候都可以用子类型替换掉父类型。（关于里氏替换原则的描述，Barbara Liskov女士的描述比这个要复杂得多，但简单的说就是能用父类型的地方就一定能使用子类型。里氏替换原则可以检查继承关系是否合理，如果一个继承关系违背了里氏替换原则，那么这个继承关系一定是错误的，需要对代码进行重构。例如让猫继承狗，或者狗继承猫，又或者让正方形继承长方形都是错误的继承关系，因为你很容易找到违反里氏替换原则的场景。需要注意的是：子类一定是增加父类的能力而不是减少父类的能力，因为子类比父类的能力更多，把能力多的对象当成能力少的对象来用当然没有任何问题。）代表约定、代表角色，能否正确的使用接口一定是编程水平高低的重要标识。）
依赖倒置原则（Dependecy-Inversion Principle） 面向接口编程。（该原则说得直白和具体一些就是声明方法的参数类型、方法的返回类型、变量的引用类型时，尽可能使用抽象类型而不用具体类型，因为抽象类型可以被它的任何一个子类型所替代，请参考下面的里氏替换原则。）
接口隔离原则（Interface-Segregation Principle） 接口要小而专，绝不能大而全。（臃肿的接口是对接口的污染，既然接口表示能力，那么一个接口只应该描述一种能力，接口也应该是高度内聚的。例如，琴棋书画就应该分别设计为四个接口，而不应设计成一个接口中的四个方法，因为如果设计成一个接口中的四个方法，那么这个接口很难用，毕竟琴棋书画四样都精通的人还是少数，而如果设计成四个接口，会几项就实现几个接口，这样的话每个接口被复用的可能性是很高的。Java中的接口代表能力、 分离的手段主要有以下两种：1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。
合成聚合复用原则 优先使用聚合或合成关系复用代码。（通过继承来复用代码是面向对象程序设计中被滥用得最多的东西，因为所有的教科书都无一例外的对继承进行了鼓吹从而误导了初学者，类与类之间简单的说有三种关系，Is-A关系、Has-A关系、Use-A关系，分别代表继承、关联和依赖。其中，关联关系根据其关联的强度又可以进一步划分为关联、聚合和合成，但说白了都是Has-A关系，合成聚合复用原则想表达的是优先考虑Has-A关系而不是Is-A关系复用代码，原因嘛可以自己从百度上找到一万个理由，需要说明的是，即使在Java的API中也有不少滥用继承的例子，例如Properties类继承了Hashtable类，Stack类继承了Vector类，这些继承明显就是错误的，更好的做法是在Properties类中放置一个Hashtable类型的成员并且将其键和值都设置为字符串来存储数据，而Stack类的设计也应该是在Stack类中放一个Vector对象来存储数据。记住：任何时候都不要继承工具类，工具是可以拥有并可以使用的，而不是拿来继承的。）
迪米特法则 迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。再复杂的系统都可以为用户提供一个简单的门面，Java Web开发中作为前端控制器的Servlet或Filter不就是一个门面吗，浏览器对服务器的运作方式一无所知，但是通过前端控制器就能够根据你的请求得到相应的服务。调停者模式也可以举一个简单的例子来说明，例如一台计算机，CPU、内存、硬盘、显卡、声卡各种设备需要相互配合才能很好的工作，但是如果这些东西都直接连接到一起，计算机的布线将异常复杂，在这种情况下，主板作为一个调停者的身份出现，它将各个设备连接在一起而不需要每个设备之间直接交换数据，这样就减小了系统的耦合度和复杂度。
Java如何实现的平台无关 Java语言规范 通过规定Java语言中基本数据类型的取值范围和行为 Class文件 所有Java文件要编译成统一的Class文件 Java虚拟机 通过Java虚拟机将Class文件转成对应平台的二进制文件等 JVM支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）
值传递、引用传递 Java中只有值传递
public class Main { public static void main(String[] args) { int a = 10; Integer b = 20; int[] arr = {1, 2}; swap(a, b); System....</p></section><footer class=entry-footer>2019-05-01&nbsp;·&nbsp;3 min</footer><a class=entry-link aria-label="post link to Java基础复习（一）" href=https://razielez.github.io/posts/java%E5%A4%8D%E4%B9%A0%E4%B8%80/></a></article><article class=post-entry><header class=entry-header><h2>设计模式复习</h2></header><section class=entry-content><p>设计模式复习 23种设计模式主要分为三类：创建型模式、结构型模式、行为型模式。
创建型模式 单例模式 实现单例模式的思路是：一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。
代码实现 饿汉式 线程安全 class Singleton { private static Singleton instance = new Singleton(); private Singleton() {} public static Singleton getInstance() { return instance; } } 懒汉式 双向检查锁定 class Singleton { // volatile 多线程安全, 但屏蔽Java虚拟机优化, 效率降低 private volatile static Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if (instance == null) { // 锁定代码块 synchronized (Singleton....</p></section><footer class=entry-footer>2019-04-01&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to 设计模式复习" href=https://razielez.github.io/posts/%E9%9D%A2%E8%AF%95-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%A4%8D%E4%B9%A0/></a></article><article class=post-entry><header class=entry-header><h2>常见排序算法实现</h2></header><section class=entry-content><p>排序比较 快速排序 /** * 快速排序算法 */ public static void quickSort(int[] list, int left, int right) { if (left &lt; right) { // 分割数组，找到分割点 int point = partition(list, left, right); // 递归调用，对左子数组进行快速排序 quickSort(list, left, point - 1); // 递归调用，对右子数组进行快速排序 quickSort(list, point + 1, right); } } /** * 分割数组，找到分割点 */ public static int partition(int[] list, int left, int right) { // 用数组的第一个元素作为基准数 int first = list[left]; while (left &lt; right) { while (left &lt; right && list[right] >= first) { right--; } // 交换 swap(list, left, right); while (left &lt; right && list[left] &lt;= first) { left++; } // 交换 swap(list, left, right); } // 返回分割点所在的位置 return left; } /** * 交换数组中两个位置的元素 */ public static void swap(int[] list, int left, int right) { int temp; if (list !...</p></section><footer class=entry-footer>2019-02-20&nbsp;·&nbsp;4 min</footer><a class=entry-link aria-label="post link to 常见排序算法实现" href=https://razielez.github.io/posts/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95java%E5%AE%9E%E7%8E%B0/></a></article><article class=post-entry><header class=entry-header><h2>问卷星自动提交脚本</h2></header><section class=entry-content><p>思路 分析页面结构, 问题标号: q+第几题, 问题选项: q+第几题+_第几个选项. 对一次提交进行抓包, 抓取post数据包. 对submidata进行解码得到如下. 明显看出是题号$选项号}组成的.
写python脚本构造post请求.利用X-Forwarded-For绕过服务器IP地址过滤.
import requests from time import * from random import randint for i in range(10): header = { 'Host': 'www.wjx.cn', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:63.0) Gecko/20100101 Firefox/63.0', 'X-Forwarded-For': str(randint(1, 255)) + '.' + str(randint(1, 255)) + '.' + str(randint(1, 255)) + '.' + str( randint(1, 255)), 'Referer': 'https://www.wjx.cn###.aspx', 'Cookie': 'acw_tc=2f624a1f154##', } print("第 " + str(i) + " 提交" + " Using IP:" + header['X-Forwarded-For'] + ' to compalte this Q....</p></section><footer class=entry-footer>2019-01-01&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 问卷星自动提交脚本" href=https://razielez.github.io/posts/%E9%97%AE%E5%8D%B7%E6%98%9F%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4%E8%84%9A%E6%9C%AC/></a></article><article class=post-entry><header class=entry-header><h2>Manacher算法-最长回文串</h2></header><section class=entry-content><p>题目 求解字符串最长回文串。
leetcode: 最长回文子串
样例 Input 121
1
daccbba
bb
Output 121
1
accbba
bb
Manacher算法，时间复杂度O(n), 空间复杂度O(1)。
步骤 先对s串处理转换为奇数长度的串。
s = "12212321"
==>
S # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 #
P 1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1
p[i]表示记录以字符S[i]为中心的最长回文子串向左或向右扩张的长度（包括S[i]）。 即以i为原点的最大回文半径。
Manacher算法增加两个辅助变量id和mx。
id代表当前“已经匹配完毕的结尾最远的回文串”中心为s的第ID位。
mx = p[i] + id代表当前“已经匹配完毕的结尾最远的回文串”到达了s的第Mx位。
最长回文子串长度 = p[i] - 1 = 5。...</p></section><footer class=entry-footer>2018-11-15&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Manacher算法-最长回文串" href=https://razielez.github.io/posts/manacher-%E5%9B%9E%E6%96%87%E4%B8%B2/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://razielez.github.io/posts/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://razielez.github.io>Razielez's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>